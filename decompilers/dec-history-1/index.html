<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Decompilation Wiki is a categorized information hub for works and applications of decompilation."><meta name=author content="Decompilation Wiki Team"><link href=https://decompilation.wiki/decompilers/dec-history-1/ rel=canonical><link href=../tools/ rel=prev><link href=../father-of-dec/ rel=next><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.7.0"><title>History of Decompilation (1960-2007) - Decompilation Wiki</title><link rel=stylesheet href=../../assets/stylesheets/main.618322db.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.ab4e12ef.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans:300,300i,400,400i,700,700i%7CSource+Code+Pro:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Noto Sans";--md-code-font:"Source Code Pro"}</style><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=orange data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#history-of-decompilation-1960-2007 class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Decompilation Wiki" class="md-header__button md-logo" aria-label="Decompilation Wiki" data-md-component=logo> <img src=../../static/img/logo.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Decompilation Wiki </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> History of Decompilation (1960-2007) </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/mahaloz/decompilation-wiki title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> mahaloz/decompilation-wiki </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> About üè† </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../directory/ class=md-tabs__link> Decompilers üíæ </a> </li> <li class=md-tabs__item> <a href=../../fundamentals/overview/ class=md-tabs__link> Fundamentals üîç </a> </li> <li class=md-tabs__item> <a href=../../applied-research/overview/ class=md-tabs__link> Applied Research ‚öôÔ∏è </a> </li> <li class=md-tabs__item> <a href=../../applications/overview/ class=md-tabs__link> Applications üåç </a> </li> <li class=md-tabs__item> <a href=../../misc/blogs/ class=md-tabs__link> Misc üì¶ </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Decompilation Wiki" class="md-nav__button md-logo" aria-label="Decompilation Wiki" data-md-component=logo> <img src=../../static/img/logo.png alt=logo> </a> Decompilation Wiki </label> <div class=md-nav__source> <a href=https://github.com/mahaloz/decompilation-wiki title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> mahaloz/decompilation-wiki </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0> <span class=md-ellipsis> About üè† </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> About üè† </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> The Decompilation Wiki </span> </a> </li> <li class=md-nav__item> <a href=../../contributing/ class=md-nav__link> <span class=md-ellipsis> Contributing Guide </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> Decompilers üíæ </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Decompilers üíæ </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../directory/ class=md-nav__link> <span class=md-ellipsis> Decompiler Directory </span> </a> </li> <li class=md-nav__item> <a href=../tools/ class=md-nav__link> <span class=md-ellipsis> Tools </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> History of Decompilation (1960-2007) </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> History of Decompilation (1960-2007) </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#maintainers-note class=md-nav__link> <span class=md-ellipsis> Maintainers Note </span> </a> </li> <li class=md-nav__item> <a href=#why-decompilation class=md-nav__link> <span class=md-ellipsis> Why Decompilation? </span> </a> <nav class=md-nav aria-label="Why Decompilation?"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#why-not-just-disassemble class=md-nav__link> <span class=md-ellipsis> Why not just disassemble? </span> </a> </li> <li class=md-nav__item> <a href=#applications class=md-nav__link> <span class=md-ellipsis> Applications </span> </a> </li> <li class=md-nav__item> <a href=#software-freedoms class=md-nav__link> <span class=md-ellipsis> Software Freedoms </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#timeline-overview class=md-nav__link> <span class=md-ellipsis> Timeline Overview </span> </a> <nav class=md-nav aria-label="Timeline Overview"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#part-1 class=md-nav__link> <span class=md-ellipsis> Part 1 </span> </a> </li> <li class=md-nav__item> <a href=#part-2 class=md-nav__link> <span class=md-ellipsis> Part 2 </span> </a> </li> <li class=md-nav__item> <a href=#part-3 class=md-nav__link> <span class=md-ellipsis> Part 3 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#history-1960-1979 class=md-nav__link> <span class=md-ellipsis> History: 1960-1979 </span> </a> <nav class=md-nav aria-label="History: 1960-1979"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#d-neliac-decompiler-1960 class=md-nav__link> <span class=md-ellipsis> D-Neliac decompiler, 1960 </span> </a> </li> <li class=md-nav__item> <a href=#the-lockheed-neliac-decompiler-1963-7 class=md-nav__link> <span class=md-ellipsis> The Lockheed Neliac Decompiler, 1963-7 </span> </a> </li> <li class=md-nav__item> <a href=#wsassaman-1966 class=md-nav__link> <span class=md-ellipsis> W.Sassaman, 1966 </span> </a> </li> <li class=md-nav__item> <a href=#autocoder-to-cobol-conversion-aid-program-1967 class=md-nav__link> <span class=md-ellipsis> Autocoder to Cobol Conversion Aid Program, 1967 </span> </a> </li> <li class=md-nav__item> <a href=#the-inverse-compiler-1972-6 class=md-nav__link> <span class=md-ellipsis> The Inverse Compiler, 1972-6 </span> </a> </li> <li class=md-nav__item> <a href=#crhollander-1973 class=md-nav__link> <span class=md-ellipsis> C.R.Hollander, 1973 </span> </a> </li> <li class=md-nav__item> <a href=#bchousel-1973 class=md-nav__link> <span class=md-ellipsis> B.C.Housel, 1973 </span> </a> </li> <li class=md-nav__item> <a href=#the-piler-system-1974 class=md-nav__link> <span class=md-ellipsis> The Piler System, 1974 </span> </a> </li> <li class=md-nav__item> <a href=#flfriedman-1974 class=md-nav__link> <span class=md-ellipsis> F.L.Friedman, 1974 </span> </a> </li> <li class=md-nav__item> <a href=#ultrasystems-1974 class=md-nav__link> <span class=md-ellipsis> Ultrasystems, 1974 </span> </a> </li> <li class=md-nav__item> <a href=#vschneider-and-gwiniger-1974 class=md-nav__link> <span class=md-ellipsis> V.Schneider and G.Winiger, 1974 </span> </a> </li> <li class=md-nav__item> <a href=#l-peter-deutsch-1977-1979 class=md-nav__link> <span class=md-ellipsis> L Peter Deutsch 1977-1979 </span> </a> </li> <li class=md-nav__item> <a href=#decompilation-of-polish-code-1977-1981-1988 class=md-nav__link> <span class=md-ellipsis> Decompilation of Polish code, 1977, 1981, 1988 </span> </a> </li> <li class=md-nav__item> <a href=#glhopwood-1978 class=md-nav__link> <span class=md-ellipsis> G.L.Hopwood, 1978 </span> </a> </li> <li class=md-nav__item> <a href=#daworkman-1978 class=md-nav__link> <span class=md-ellipsis> D.A.Workman, 1978 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#history-1980-1999 class=md-nav__link> <span class=md-ellipsis> History: 1980-1999 </span> </a> <nav class=md-nav aria-label="History: 1980-1999"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#zebra-1981 class=md-nav__link> <span class=md-ellipsis> Zebra, 1981 </span> </a> </li> <li class=md-nav__item> <a href=#decompilation-of-dml-programs-1982 class=md-nav__link> <span class=md-ellipsis> Decompilation of DML programs, 1982 </span> </a> </li> <li class=md-nav__item> <a href=#forth-decompiler-1982-1984 class=md-nav__link> <span class=md-ellipsis> Forth Decompiler, 1982, 1984 </span> </a> </li> <li class=md-nav__item> <a href=#dataflex-decompilers-1984 class=md-nav__link> <span class=md-ellipsis> Dataflex Decompilers, 1984 </span> </a> </li> <li class=md-nav__item> <a href=#software-transport-system-1985 class=md-nav__link> <span class=md-ellipsis> Software Transport System, 1985 </span> </a> </li> <li class=md-nav__item> <a href=#decomp-1988 class=md-nav__link> <span class=md-ellipsis> Decomp, 1988 </span> </a> </li> <li class=md-nav__item> <a href=#fermat-1989-to-present class=md-nav__link> <span class=md-ellipsis> FermaT, 1989 to present </span> </a> </li> <li class=md-nav__item> <a href=#exe2c-1990 class=md-nav__link> <span class=md-ellipsis> exe2c, 1990 </span> </a> </li> <li class=md-nav__item> <a href=#plm-80-decompiler-1991 class=md-nav__link> <span class=md-ellipsis> PLM-80 Decompiler, 1991 </span> </a> </li> <li class=md-nav__item> <a href=#j-ogorman-phd-thesis-1991 class=md-nav__link> <span class=md-ellipsis> J. O'Gorman PhD thesis, 1991 </span> </a> </li> <li class=md-nav__item> <a href=#decompiler-compiler-1991-1994 class=md-nav__link> <span class=md-ellipsis> Decompiler compiler, 1991-1994 </span> </a> </li> <li class=md-nav__item> <a href=#8086-c-decompiling-system-1991-1993 class=md-nav__link> <span class=md-ellipsis> 8086 C Decompiling System, 1991-1993 </span> </a> </li> <li class=md-nav__item> <a href=#alpha-axp-migration-tools-1993 class=md-nav__link> <span class=md-ellipsis> Alpha AXP Migration Tools, 1993 </span> </a> </li> <li class=md-nav__item> <a href=#sourceprom-comparator-1993 class=md-nav__link> <span class=md-ellipsis> Source/PROM Comparator, 1993 </span> </a> </li> <li class=md-nav__item> <a href=#cristina-cifuentes-phd-thesis-reverse-compilation-techniques-1994 class=md-nav__link> <span class=md-ellipsis> Cristina Cifuentes' PhD Thesis "Reverse Compilation Techniques", 1994 </span> </a> </li> <li class=md-nav__item> <a href=#decler-decompiler-1995 class=md-nav__link> <span class=md-ellipsis> DECLER Decompiler, 1995 </span> </a> </li> <li class=md-nav__item> <a href=#university-of-queensland-binary-translator-1997-2001 class=md-nav__link> <span class=md-ellipsis> University of Queensland Binary Translator, 1997-2001 </span> </a> </li> <li class=md-nav__item> <a href=#a-mycrofts-type-reconstruction-for-decompilation-1999 class=md-nav__link> <span class=md-ellipsis> A. Mycroft's Type Reconstruction for Decompilation, 1999 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#history-2000-2007 class=md-nav__link> <span class=md-ellipsis> History: 2000-2007 </span> </a> <nav class=md-nav aria-label="History: 2000-2007"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#university-of-londons-asm21toc-reverse-compiler-2000 class=md-nav__link> <span class=md-ellipsis> University of London's Asm21toc reverse compiler, 2000. </span> </a> </li> <li class=md-nav__item> <a href=#proof-directed-de-compilation-of-low-level-code-2001 class=md-nav__link> <span class=md-ellipsis> Proof-Directed De-compilation of Low-Level Code, 2001. </span> </a> </li> <li class=md-nav__item> <a href=#computer-security-analysis-through-decompilation-and-high-level-debugging-2001 class=md-nav__link> <span class=md-ellipsis> Computer Security Analysis through Decompilation and High-Level Debugging, 2001. </span> </a> </li> <li class=md-nav__item> <a href=#type-propagation-in-ida-pro-disassembler-2001 class=md-nav__link> <span class=md-ellipsis> Type Propagation in IDA Pro Disassembler, 2001. </span> </a> </li> <li class=md-nav__item> <a href=#disc-by-satish-kumar-2001 class=md-nav__link> <span class=md-ellipsis> DisC, by Satish Kumar, 2001. </span> </a> </li> <li class=md-nav__item> <a href=#ndcc-decompiler-2002 class=md-nav__link> <span class=md-ellipsis> ndcc decompiler, 2002. </span> </a> </li> <li class=md-nav__item> <a href=#the-anatomizer-decompiler-circa-2002 class=md-nav__link> <span class=md-ellipsis> The Anatomizer Decompiler, circa 2002. </span> </a> </li> <li class=md-nav__item> <a href=#analysis-of-virtual-method-invocation-for-binary-translation-2002 class=md-nav__link> <span class=md-ellipsis> Analysis of Virtual Method Invocation for Binary Translation, 2002. </span> </a> </li> <li class=md-nav__item> <a href=#boomerang-2002 class=md-nav__link> <span class=md-ellipsis> Boomerang, 2002. </span> </a> </li> <li class=md-nav__item> <a href=#desquirr-2002 class=md-nav__link> <span class=md-ellipsis> Desquirr, 2002. </span> </a> </li> <li class=md-nav__item> <a href=#analyzing-memory-accesses-in-x86-executables-2004 class=md-nav__link> <span class=md-ellipsis> Analyzing Memory Accesses in x86 Executables, 2004. </span> </a> </li> <li class=md-nav__item> <a href=#r-falkes-type-analysis-for-decompilers-2004 class=md-nav__link> <span class=md-ellipsis> R. Falke's Type Analysis for Decompilers, 2004 </span> </a> </li> <li class=md-nav__item> <a href=#andromeda-decompiler-2004-2005 class=md-nav__link> <span class=md-ellipsis> Andromeda Decompiler, 2004-2005. </span> </a> </li> <li class=md-nav__item> <a href=#hex-rays-decompiler-plugin-2007 class=md-nav__link> <span class=md-ellipsis> Hex Rays Decompiler Plugin, 2007. </span> </a> </li> <li class=md-nav__item> <a href=#static-single-assignment-for-decompilation-2007 class=md-nav__link> <span class=md-ellipsis> Static Single Assignment for Decompilation, 2007. </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> <span class=md-ellipsis> References </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../father-of-dec/ class=md-nav__link> <span class=md-ellipsis> The Father of Decompilation (1960-2007) </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Fundamentals üîç </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Fundamentals üîç </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_2> <label class=md-nav__link for=__nav_3_2 id=__nav_3_2_label tabindex=0> <span class=md-ellipsis> Control Flow Graph Recovery </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_3_2_label aria-expanded=false> <label class=md-nav__title for=__nav_3_2> <span class="md-nav__icon md-icon"></span> Control Flow Graph Recovery </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/cfg-recovery/overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/cfg-recovery/disassembly/ class=md-nav__link> <span class=md-ellipsis> Disassembling </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/cfg-recovery/lifting/ class=md-nav__link> <span class=md-ellipsis> Program Lifting </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/cfg-recovery/function-recovery/ class=md-nav__link> <span class=md-ellipsis> Function Identification </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/cfg-recovery/jump-resolving/ class=md-nav__link> <span class=md-ellipsis> Jump Resolving </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_3> <label class=md-nav__link for=__nav_3_3 id=__nav_3_3_label tabindex=0> <span class=md-ellipsis> Type Recovery </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_3_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3_3> <span class="md-nav__icon md-icon"></span> Type Recovery </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/type-recovery/overview/ class=md-nav__link> <span class=md-ellipsis> Type Recovery Overview </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/type-recovery/var-detection/ class=md-nav__link> <span class=md-ellipsis> Variable Detection </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_3_3> <label class=md-nav__link for=__nav_3_3_3 id=__nav_3_3_3_label tabindex=0> <span class=md-ellipsis> Lattice Based </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_3_3_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3_3_3> <span class="md-nav__icon md-icon"></span> Lattice Based </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/type-recovery/lattice-constraint-simp/ class=md-nav__link> <span class=md-ellipsis> Constraint Simplification </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_4> <label class=md-nav__link for=__nav_3_4 id=__nav_3_4_label tabindex=0> <span class=md-ellipsis> Control Flow Structuring </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_3_4_label aria-expanded=false> <label class=md-nav__title for=__nav_3_4> <span class="md-nav__icon md-icon"></span> Control Flow Structuring </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/structuring/overview/ class=md-nav__link> <span class=md-ellipsis> Structuring Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_4_2> <label class=md-nav__link for=__nav_3_4_2 id=__nav_3_4_2_label tabindex=0> <span class=md-ellipsis> Schema Based </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_3_4_2_label aria-expanded=false> <label class=md-nav__title for=__nav_3_4_2> <span class="md-nav__icon md-icon"></span> Schema Based </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../fundamentals/structuring/schema-based/schema-based/ class=md-nav__link> <span class=md-ellipsis> Schema-based Structuring </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/structuring/schema-based/switch-structuring/ class=md-nav__link> <span class=md-ellipsis> Switch Structuring </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../fundamentals/structuring/gotoless/ class=md-nav__link> <span class=md-ellipsis> Gotoless Structuring </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/structuring/loop-reduction/ class=md-nav__link> <span class=md-ellipsis> Loop Reduction </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../fundamentals/evaluation/ class=md-nav__link> <span class=md-ellipsis> Quality Evaluation </span> </a> </li> <li class=md-nav__item> <a href=../../fundamentals/neural-decompilation/ class=md-nav__link> <span class=md-ellipsis> Neural Decompilation </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> Applied Research ‚öôÔ∏è </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Applied Research ‚öôÔ∏è </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../applied-research/overview/ class=md-nav__link> <span class=md-ellipsis> Applied Research Overview </span> </a> </li> <li class=md-nav__item> <a href=../../applied-research/symbol-recovery/ class=md-nav__link> <span class=md-ellipsis> Symbol Recovery </span> </a> </li> <li class=md-nav__item> <a href=../../applied-research/code-similarity/ class=md-nav__link> <span class=md-ellipsis> Code Similarity </span> </a> </li> <li class=md-nav__item> <a href=../../applied-research/vulnerability-discovery/ class=md-nav__link> <span class=md-ellipsis> Vulnerability Discovery </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> Applications üåç </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> Applications üåç </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../applications/overview/ class=md-nav__link> <span class=md-ellipsis> Decompiler Applications </span> </a> </li> <li class=md-nav__item> <a href=../../applications/program-reconstruction/ class=md-nav__link> <span class=md-ellipsis> Program Reconstruction </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6 id=__nav_6_label tabindex=0> <span class=md-ellipsis> Misc üì¶ </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_6_label aria-expanded=false> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> Misc üì¶ </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../misc/blogs/ class=md-nav__link> <span class=md-ellipsis> Community Blogs </span> </a> </li> <li class=md-nav__item> <a href=../../misc/talks/ class=md-nav__link> <span class=md-ellipsis> Talks </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=history-of-decompilation-1960-2007>History of Decompilation (1960-2007)<a class=headerlink href=#history-of-decompilation-1960-2007 title="Permanent link">&para;</a></h1> <h2 id=maintainers-note>Maintainers Note<a class=headerlink href=#maintainers-note title="Permanent link">&para;</a></h2> <p>The following text is a clone, with small fixes, of the popular <a href=https://web.archive.org/web/20250209230334/https://www.program-transformation.org/Transform/DeCompilation.html>Program-Transformation Wiki</a>, which went offline in 2025. All credits to the following text on this page go to the original creators of the Program-Transformation Wiki. The maintainers of the Decompilation Wiki do not claim credit for it, but instead preserve it here for future researchers in decompilation. </p> <h2 id=why-decompilation>Why Decompilation?<a class=headerlink href=#why-decompilation title="Permanent link">&para;</a></h2> <h3 id=why-not-just-disassemble>Why not just disassemble?<a class=headerlink href=#why-not-just-disassemble title="Permanent link">&para;</a></h3> <p>Consider the Java world, where there are simple disassemblers and sophisticated decompilers that often work well and with little user intervention. Would you use a Java disassembler to try to understand some Java bytecode program? Most likely not. If there is a good decompiler available, you don't need to see the individual instructions. If and when a good decompiler for executable programs becomes available, it will be a better choice than a disassembler in most circumstances.</p> <h3 id=applications>Applications<a class=headerlink href=#applications title="Permanent link">&para;</a></h3> <p>There are many reasons why you might want to decompile a program. Here are some of them, based on this diagram:</p> <p><img alt src=/static/img/tree120.png></p> <p>If the output is considered...</p> <ul> <li>A comprehension aid. You don't have the resources to create compilable code. Even so, you can do these things:<ul> <li>You can perform code checking of various kinds:<ul> <li>Find bugs. You focus on the area of the program that you are interested in. looking for bugs.</li> <li>Find vulnerabilities. You scan the whole program, looking for code that could be exploited.</li> <li>Find malware. Again you scan the whole program, this time looking for code that has already been exploited. It may be easier and quicker to find malware in 1000 lines of C than in 10,000 lines of assembler.</li> <li>Verification. You want to make sure that the binary code that you have corresponds to the source code that you also have. This is important in safety critical applications.</li> <li>Comparison. Suppose you are accused of violating a software patent, or suspect that someone has violated your patent. You can show how different or similar two programs are by comparing decompiled source code. To some extent, a decompiler can make two different implementations of the same program reveal their similarities. As an example of this, using different optimisations with the same compiler somtimes results in similar decompiled code.</li> </ul> </li> <li>Learn Algorithm. To the extent that is allowable by law, you might want to discover how a particular feature of a piece of software is implemented. It's a little bit like browsing patents online; you can't use what you see directly in a commercial setting, unless you have an arrangement with the author.</li> <li>Interoperability. It may be legal and necessary to reverse engineer some binary code for the purposes of interoperability. There are the famous cases of Sega vs Accolade and Atari v Nintendo, where small games companies successfully argued their right to reverse engineer some existing games, so that they could manufacture competing games for that platform. I don't know if they used decompilation for this (probably not), but it's a good example of iwhere decompilation might make a difficult job much easier.</li> </ul> </li> <li>If you have compilable code, then you can do more:<ul> <li>With little user input:<ul> <li>Optimise for platform. Example: you have an old program written for the 80286 processor, but you have a Pentium 4. You can recompile the code with optimisations appropriate for your actual hardware.</li> <li>Port cross platform (where the same libraries are available). For example, you have an Intel Windows version of a program, but you have an Alpha (running Windows NT). You can recompile the decompiled output with an Alpha compiler. Or recompile it with <a href=https://web.archive.org/web/20250217181056/http://www.winehq.com/site/winelib>Winelib</a> (to provide Windows libraries) and run the "Windows" program natively on your PPC laptop under Linux. Or compile it under <a href=https://web.archive.org/web/20250217181056/http://darwine.opendarwin.org/ >Darwine</a> on your Mac running OS/X. If the vendor doesn't provide one, a 64-bit driver (required for 64-bit Windows XP) might be rewritten from the decompilation of a 32-bit driver. Decompiling or disassembling an existing driver binary may be the only way to find interoperability information, e.g. to write a Linux driver.</li> </ul> </li> <li>If you put enough effort into the decompilation to produce maintainable code, you can also:<ul> <li>Fix bugs (without the tediom of patching the binary file).</li> <li>You can also add new features that were not in the original program.</li> <li>You can recover lost or unusable source code. It is estimated that 5% of all software in the world has at least some source files missing. You can use the decompiled code to replace the missing source file(s). You can also maintain code that was written in assembler, or in a language for which the compilers no longer exist.</li> </ul> </li> </ul> </li> </ul> <p>Some more decompilation applications that don't fit very well into the above classification:</p> <ul> <li>Defeating copy protection, where the company who wrote the software (that you paid for) is out of business, and you can't transfer it to a new machine. It does happen!</li> <li>Support for programs that ship without debugging information, often linking with third party code, and one day it just stops working. Recompiling with debugging support turned on may or may not show the fault. People experience this problem in the field all the time, and at present the tools they have to work with are inadequate. Decompilation may be able to ease the support burden, even for companies that have the source code (except perhaps to some third party code).</li> </ul> <h3 id=software-freedoms>Software Freedoms<a class=headerlink href=#software-freedoms title="Permanent link">&para;</a></h3> <p>On a <a href=https://web.archive.org/web/20250217181056/http://www.slashdot.org/ >SlashDot</a> articled called <a href="https://web.archive.org/web/20250217181056/http://linux.slashdot.org/linux/05/04/11/1413232.shtml?tid=99&tid=106">"BitKeeper Love Triangle: McVoy, Linus and Tridge"</a> 11/Apr/2005), it was posted:</p> <p><em>"The purpose of copyrights is to advance science and useful arts, not to reward authors.</em></p> <p><em>If rewarding authors for that purpose is required, then they will be rewarded.</em></p> <p><em>Copyrights on binaries however, reward authors while stifling the progress of science and useful arts.</em></p> <p><em>It encourages people to create secretly-operating software that helps them get revenue but does not inspire new works, does not enter the public</em> <em>domain and does not help anyone else in the long run.</em></p> <p>So what if publishing your binary was almost as useful as publishing source code? Decompilation is not yet at a stage where this is true, but in 5-10 years, it may well be. Decompilation could then become a tool for software freedom.</p> <p>Here is another quote, this time from <a href=https://web.archive.org/web/20250217181056/http://www.vjolt.net/vol8/issue1/v8i1_a02-Dixon.pdf>"Breaking into Locked Rooms to Access Computer Source Code: Does the DMCA Violate a Constitutional Mandate When Technological Barriers of Access Are Applied to Software?"</a> by Rod Dixon of Virginia Journal of Law and Technology:</p> <p><em>"27. For non-software literary works, once the work is published, the</em> <em>ideas contained in the work become apparent and conspicuous. In this</em> <em>manner, the work's basic ideas may provide a basis for further</em> <em>development of additional works by any member of the public with</em> <em>access to the work. This is a critical function of the public domain</em> <em>because it serves the primary purpose of copyright. ... The enrichment</em> <em>of the public domain of ideas increases the public's access to works,</em> <em>which further enriches the public domain. Software, however, presents</em> <em>a slight conundrum that disrupts the flow of the recursive enrichment</em> <em>of the public domain served by copyright law."</em></p> <p>Again, decompilation may (if the laws are written correctly) allow the ideas contained in programs not released with source code to become available to the public domain, as they were always intended to. The novel ideas can be patented (unless you believe that all software patents are bad); this does at least disclose the ideas (they are freely readable by all) and can freely be used by all once the patent expires.</p> <h2 id=timeline-overview>Timeline Overview<a class=headerlink href=#timeline-overview title="Permanent link">&para;</a></h2> <h3 id=part-1>Part 1<a class=headerlink href=#part-1 title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>Years</th> <th>Work</th> </tr> </thead> <tbody> <tr> <td>1960, 1962</td> <td><a href=HistoryOfDecompilation1.html#TopicDNeliac>D-Neliac decompiler</a></td> </tr> <tr> <td>1963‚Äì1967</td> <td><a href=HistoryOfDecompilation1.html#TopicLockheed>The Lockheed Neliac decompiler</a></td> </tr> <tr> <td>1966</td> <td><a href=HistoryOfDecompilation1.html#TopicSassaman>W. Sassaman</a></td> </tr> <tr> <td>1967</td> <td><a href=HistoryOfDecompilation1.html#TopicAutocoder>Autocoder to Cobol translator</a></td> </tr> <tr> <td>1972‚Äì1976</td> <td><a href=HistoryOfDecompilation1.html#TopicInverse>The Inverse Compiler</a></td> </tr> <tr> <td>1973</td> <td><a href=HistoryOfDecompilation1.html#TopicHollander>C. R. Hollander PhD thesis</a></td> </tr> <tr> <td>1973</td> <td><a href=HistoryOfDecompilation1.html#TopicHousel>B. C. Housel PhD thesis</a></td> </tr> <tr> <td>1974</td> <td><a href=HistoryOfDecompilation1.html#TopicPiler>The Piler System</a></td> </tr> <tr> <td>1974</td> <td><a href=HistoryOfDecompilation1.html#TopicFriedman>F. L. Friedman PhD thesis</a></td> </tr> <tr> <td>1974</td> <td><a href=HistoryOfDecompilation1.html#TopicUltrasystems>Ultrasystems</a></td> </tr> <tr> <td>1974</td> <td><a href=HistoryOfDecompilation1.html#TopicSchneider>V. Schneider and G. Winiger</a></td> </tr> <tr> <td>1977‚Äì1979</td> <td><a href=HistoryOfDecompilation1.html#TopicDeutsch>L. Peter Deutsch</a></td> </tr> <tr> <td>1977, 1981, 1988</td> <td><a href=HistoryOfDecompilation1.html#TopicPilish>Decompilation of Polish code</a></td> </tr> <tr> <td>1978</td> <td><a href=HistoryOfDecompilation1.html#TopicHopwood>G. L. Hopwood PhD thesis</a></td> </tr> <tr> <td>1978</td> <td><a href=HistoryOfDecompilation1.html#TopicWorkman>D. A. Workman</a></td> </tr> </tbody> </table> <h3 id=part-2>Part 2<a class=headerlink href=#part-2 title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>Years</th> <th>Work</th> </tr> </thead> <tbody> <tr> <td>1981</td> <td><a href=HistoryOfDecompilation2.html#TopicZebra>Zebra</a></td> </tr> <tr> <td>1982</td> <td><a href=HistoryOfDecompilation2.html#TopicDML>Decompilation of DML programs</a></td> </tr> <tr> <td>1982, 1984</td> <td><a href=HistoryOfDecompilation2.html#TopicForth>Forth Decompiler</a></td> </tr> <tr> <td>1984</td> <td><a href=HistoryOfDecompilation2.html#TopicDataflex>Dataflex Decompilers</a></td> </tr> <tr> <td>1985</td> <td><a href=HistoryOfDecompilation2.html#TopicSoft>Software transport system</a></td> </tr> <tr> <td>1988</td> <td><a href=HistoryOfDecompilation2.html#TopicDecomp>J. Reuter's Decomp VAX BSD decompiler</a></td> </tr> <tr> <td>1989</td> <td><a href=HistoryOfDecompilation2.html#TopicFermat>FermaT</a></td> </tr> <tr> <td>1990</td> <td><a href=HistoryOfDecompilation2.html#TopicAustin>Austin Code Works‚Äô exe2c DOS decompiler</a></td> </tr> <tr> <td>1991</td> <td><a href=HistoryOfDecompilation2.html#TopicPLM>PLM-90 decompiler</a></td> </tr> <tr> <td>1991</td> <td><a href=HistoryOfDecompilation2.html#TopicOGorman>O‚ÄôGorman PhD thesis</a></td> </tr> <tr> <td>1991‚Äì1994</td> <td><a href=HistoryOfDecompilation2.html#TopicDecompComp>Decompiler compiler</a></td> </tr> <tr> <td>1991‚Äì1993</td> <td><a href=HistoryOfDecompilation2.html#TopicEightOhEightSix>8086 C Decompiling System</a></td> </tr> <tr> <td>1993</td> <td><a href=HistoryOfDecompilation2.html#TopicAlpha>Alpha AXP Migration Tools</a></td> </tr> <tr> <td>1993</td> <td><a href=HistoryOfDecompilation2.html#TopicSourcePROM>Source/PROM Comparator</a></td> </tr> <tr> <td>1994</td> <td><a href=HistoryOfDecompilation2.html#TopicDCC>The dcc decompiler</a></td> </tr> <tr> <td>1995</td> <td><a href=HistoryOfDecompilation2.html#TopicDECLER>DECLER Decompiler</a></td> </tr> <tr> <td>1997‚Äì2001</td> <td><a href=HistoryOfDecompilation2.html#TopicUQBT>University of Queensland Binary Translator</a></td> </tr> <tr> <td>1999</td> <td><a href=HistoryOfDecompilation2.html#TopicMycroft>A. Mycroft's Type Reconstruction for Decompilation</a></td> </tr> </tbody> </table> <h3 id=part-3>Part 3<a class=headerlink href=#part-3 title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>Years</th> <th>Work</th> </tr> </thead> <tbody> <tr> <td>2000</td> <td><a href=HistoryOfDecompilation3.html#TopicAsm21toc>University of London‚Äôs Asm21toc reverse compiler</a></td> </tr> <tr> <td>2001</td> <td><a href=HistoryOfDecompilation3.html#TopicProofDirected>Proof-Directed De-compilation of Low-Level Code</a></td> </tr> <tr> <td>2001</td> <td><a href=HistoryOfDecompilation3.html#TopicSecurityHLD>Computer Security Analysis through Decompilation and High-Level Debugging</a></td> </tr> <tr> <td>2001</td> <td><a href=HistoryOfDecompilation3.html#TopicIDATypeProp>Type Propagation in IDA Pro Disassembler</a></td> </tr> <tr> <td>2001</td> <td><a href=HistoryOfDecompilation3.html#TopicDisC>DisC, by Satish Kumar</a></td> </tr> <tr> <td>2002</td> <td><a href=HistoryOfDecompilation3.html#TopicNdcc>ndcc decompiler</a></td> </tr> <tr> <td>circa 2002</td> <td><a href=HistoryOfDecompilation3.html#TopicAnatomizer>The Anatomizer Decompiler</a></td> </tr> <tr> <td>2002</td> <td><a href=HistoryOfDecompilation3.html#TopicAnalysisVT>Analysis of Virtual Method Invocation for Binary Translation</a></td> </tr> <tr> <td>2002</td> <td><a href=HistoryOfDecompilation3.html#TopicBoomerang>Boomerang</a></td> </tr> <tr> <td>2002</td> <td><a href=HistoryOfDecompilation3.html#TopicDesquirr>Desquirr</a></td> </tr> <tr> <td>2004</td> <td><a href=HistoryOfDecompilation3.html#TopicAnalysingMem>Analyzing Memory Accesses in x86 Executables</a></td> </tr> <tr> <td>2004</td> <td><a href=HistoryOfDecompilation3.html#TopicFalkeDiploma>R. Falke‚Äôs Type Analysis for Decompilers</a></td> </tr> </tbody> </table> <h2 id=history-1960-1979>History: 1960-1979<a class=headerlink href=#history-1960-1979 title="Permanent link">&para;</a></h2> <p>Decompilers have been written for a variety of applications since the development of the first compilers. The very first decompiler was written by Joel Donnelly in 1960 at the Naval Electronic Labs to decompile machine code to Neliac on a Remington Rand Univac M-460 Countess computer. The project was supervised by Professor Maurice Halstead, who worked on decompilation during the 1960s and 70s, and published techniques which form the basis for today's decompilers. It is for this reason that we dedicate this page to the memory of Prof Maurice Halstead and award him the title of <a href=FatherOfDecompilation.html>Father of Decompilation</a>.</p> <p>Throughout the last decades, different uses have been given to decompilers. In the 1960s, decompilers were used to aid in the program conversion process from second to third generation computers; in this way, manpower would not be spent in the time-consuming task of rewriting programs for the third generation machines. During the 70s and 80s, decompilers were used for the portability of programs, documentation, debugging, re-creation of lost source code, and the modification of existing binaries. In the 90s, decompilers have become a reverse engineering tool capable of helping the user with such tasks as checking software for the existence of malicious code, checking that a compiler generates the right code, translation of binary programs from one machine to another, and understading of the implementation of a particular library function.</p> <p>The following descriptions illustrate the best-known decompilers and/or research performed into decompiler topics by individual researchers or companies. Most of these descriptions first appeared in <a href=CristinaCifuentes.html>Cristina Cifuentes</a>' <a href=HistoryOfDecompilation1.html#RefCifu94>PhD thesis</a> <em>Reverse Compilation Techniques</em>. They are reproduced herein with permission from the author.</p> <h3 id=d-neliac-decompiler-1960>D-Neliac decompiler, 1960<a class=headerlink href=#d-neliac-decompiler-1960 title="Permanent link">&para;</a></h3> <p>As reported by Halstead in [ <a href=HistoryOfDecompilation1.html#RefHals62>Hals62</a> ], the Donnelly-Neliac (D-Neliac) decompiler was produced by J.K.Donnelly and H.Englander at the Navy Electronics Laboratory (NEL) in 1960. Neliac is an Algol-type language developed at the NEL in 1955. The D-Neliac decompiler produced Neliac code from machine code programs; different versions were written for the Remington Rand Univac M-460 Countess computer and the Control Data Corporation 1604 computer. See also <a href=NeliacDecompiler.html>NeliacDecompiler</a>.</p> <p><em>D-Neliac proved useful for converting non-Neliac compiled programs into Neliac, and for detecting logic errors in the original high-level program. This decompiler proved the feasibility of writing decompilers.</em></p> <h3 id=the-lockheed-neliac-decompiler-1963-7>The Lockheed Neliac Decompiler, 1963-7<a class=headerlink href=#the-lockheed-neliac-decompiler-1963-7 title="Permanent link">&para;</a></h3> <p>The Lockheed decompiler, also known as the IBM 7094 to Univac 1108 Neliac Decompiler helped in the migration of scientific applications from the IBM 7094 to the newer Univac 1108 at Lockheed Missiles and Space. Binary card images were translated to Univac 1108 Neliac, as well as assembly code (if available). Binary code was produced from Fortran applications. As reported in [Hals70].</p> <p><em>Halstead analyzed the implementation effort required to raise the percentage of correctly decompiled instructions half way to 100%, and found that it was approximately equal to the effort already spent [ <a href=HistoryOfDecompilation1.html#RefHals70>Hals70</a> ].</em> <em>This was because decompilers from that time handled straightforward cases, but the harder cases were left for the programmer to consider. In order to handle more cases, more time was required to code these special cases into the decompiler, and this time was proportionately greater than the time required to code simple cases.</em></p> <h3 id=wsassaman-1966>W.Sassaman, 1966<a class=headerlink href=#wsassaman-1966 title="Permanent link">&para;</a></h3> <p>Sassaman developed a decompiler at TRW Inc., to aid in the conversion process of programs from 2<sup>nd</sup> to 3<sup>rd</sup> generation computers. This decompiler took as input symbolic assembler programs for the IBM 7000 series and produced Fortran programs. Binary code was not chosen as input language because the information in the symbolic assembler was more useful. Fortran was a standard language in the 1960s and ran on both 2<sup>nd</sup> and 3<sup>rd</sup> generation computers. Engineering applications which involved algebraic algorithms were the type of programs decompiled. The user was required to define rules for the recognition of subroutines. The decompiler was 90% accurate, and some manual intervention was required [ <a href=HistoryOfDecompilation1.html#RefSass66>Sass66</a> ].</p> <p><em>This decompiler makes use of assembler input programs rather than pure binary code. Assembler programs contain useful information in the form of names, macros, data and instructions, which are not available in binary or executable programs, and therefore eliminate the problem of separating data from instructions in the parsing phase of a decompiler.</em></p> <h3 id=autocoder-to-cobol-conversion-aid-program-1967>Autocoder to Cobol Conversion Aid Program, 1967<a class=headerlink href=#autocoder-to-cobol-conversion-aid-program-1967 title="Permanent link">&para;</a></h3> <p>Housel reported on a set of commercial decompilers developed by IBM to translate Autocoder programs, which were business data processing oriented, to Cobol. The translation was a one-to-one mapping and therefore manual optimization was required. The size of the final programs occupied 2.1 times the core storage of the original program [ <a href=HistoryOfDecompilation1.html#RefHous73>Hous73</a> ].</p> <p><em>This decompiler is really a translation tool of one language to another. No attempt is made to analyze the program and reduce the number of instructions generated. Inefficient code was produced in general.</em></p> <h3 id=the-inverse-compiler-1972-6>The Inverse Compiler, 1972-6<a class=headerlink href=#the-inverse-compiler-1972-6 title="Permanent link">&para;</a></h3> <p>The Inverse compiler, also known as the Sperry*Univac 494 to 1100 inverse compiler, was developed at Univac to aid in the migration to newer machines, including business applications (i.e. decompilation to <a href=COBOL.html>COBOL</a>). This decompiler was based on the Lockheed Neliac decompiler.</p> <h3 id=crhollander-1973>C.R.Hollander, 1973<a class=headerlink href=#crhollander-1973 title="Permanent link">&para;</a></h3> <p>Hollander's PhD dissertation [ <a href=HistoryOfDecompilation1.html#RefHoll73>Holl73</a> ] describes a decompiler designed around a formal syntax-oriented metalanguage, and consisting of 5 cooperating sequential processes; initializer, scanner, parser, constructor, and generator; each implemented as an interpreter of sets of metarules. The decompiler was a metasystem that defined its operations by implementing interpreters.</p> <p>The initializer loads the program and converts it into an internal representation. The scanner interacts with the initializer when finding the fields of an instruction, and interacts with the parser when matching source code templates against instructions. The parser establishes the correspondence between syntactic phrases in the source language and their semantic equivalents in the target language. Finally, the constructor and generator generate code for the final program.</p> <p>An experimental decompiler was implemented to translate a subset of IBM's System/360 assembler into an Algol-like target language. This decompiler was written in Algol-W, a compiler developed at Stanford University, and worked correctly on the 10 programs it was tested against.</p> <p><em>This work presents a novel approach to decompilation, by means of a formal syntax-oriented metalanguage, but its main drawback is precisely this methodology, which is equivalent to a pattern-matching operation of assembler instructions into high-level instructions. This limits the amount of assembler instructions that can be decompiled, as instructions that belong to a pattern need to be in a particular order to be recognized; intermediate instructions, different control flow patterns, or optimized code is not allowed. In order for syntax-oriented decompilers to work, the set of all possible patterns would need to be enumerated for each high-level instruction of each different compiler. Another approach would be to write a decompiler for a specific compiler, and make use of the specifications of that compiler; this approach is only possible if the compiler writer is willing to reveal the specifications of his compiler. It appears that Hollander's decompiler worked because the compiler specifications for the Algol-W compiler that he was using were known, as this compiler was written at the University where he was doing this research. The set of assembler instructions generated for a particular Algol-W instruction were known in this case.</em></p> <h3 id=bchousel-1973>B.C.Housel, 1973<a class=headerlink href=#bchousel-1973 title="Permanent link">&para;</a></h3> <p>Housel's PhD dissertation [ <a href=HistoryOfDecompilation1.html#RefHous73>Hous73</a> ] describes a clear approach to decompilation by borrowing concepts from compiler, graph, and optimization theory. His decompiler involves 3 major phases: partial assembly, analyzer, and code generation.</p> <p>The partial assembly phase separates data from instructions, builds a control flow graph, and generates an intermediate representation of the program. The analyzer analyzes the program in order to detect program loops and eliminate unnecessary intermediate instructions. Finally, the code generator optimizes the translation of arithmetic expressions, and generates code for the target language.</p> <p>An experimental decompiler was written for Knuth's MIX assembler (MIXAL), producing PL/1 code for the IBM 370 machines. 6 programs were tested, 88% of the generated statements were correct, and the remaining 12% required manual intervention [ <a href=HistoryOfDecompilation1.html#RefHous73b>Hous73b</a> <a href=HistoryOfDecompilation1.html#RefHH74>HH74</a> ].</p> <p>Housel made a real attempt at a general decompiler design, although his experimental decompiler was time constrained (completed in about 5 person-months). He describes a series of mappings (transformations) to a "Final Abstract Representation" and back again [ <a href=HistoryOfDecompilation1.html#RefHH74>HH74</a> ]. The experimental decompiler was extended in <a href=HistoryOfDecompilation1.html#TopicFriedman>Friedman's work</a>.</p> <p><em>This decompiler proved that by using known compiler and graph methods, a decompiler could be written that produced good high-level code. The use of an intermediate representation made the analysis completely machine independent. The main objection to this methodology is the choice of source language, MIX assembler, not only for the greater amount of information available in these programs, but for being a simplified non-real-life assembler language.</em></p> <h3 id=the-piler-system-1974>The Piler System, 1974<a class=headerlink href=#the-piler-system-1974 title="Permanent link">&para;</a></h3> <p>Barbe's Piler system attempts to be a general decompiler that translates a large class of source--target language pairs to help in the automatic translation of computer programs. The Piler system was composed of three phases: interpretation, analysis, and conversion. In this way, different interpreters could be written for different source machine languages, and different converters could be written for different target high-level languages, making it simple to write decompilers for different source--target language pairs. Other uses for this decompiler included documentation, debugging aid, and evaluation of the code generated by a compiler.</p> <p>During interpretation, the source machine program was loaded into memory, parsed and converted into a 3-address microform representation. This meant that each machine instruction required one or more microform instructions. The analyzer determined the logical structure of the program by means of data flow analysis, and modified the microform representation to an intermediate representation. A flowchart of the program after this analysis was made available to users, and they could even modify the flowchart, if there were any errors, on behalf of the decompiler. Finally, the converter generated code for the target high-level language [ <a href=HistoryOfDecompilation1.html#RefBarb74>Barb74</a> ].</p> <p>Although the Piler system attempted to be a general decompiler, only an interpreter for machine language of the GE/Honeywell 600 computer was written, and skeletal converters for Univac 1108's Fortran and Cobol were developed. The main effort of this project concentrated on the analyzer. See also <a href=PilerSystem.html>PilerSystem</a>.</p> <p><em>The Piler system was a first attempt at a general decompiler for a large class of source and target languages. Its main problem was to attempt to be general enough with the use of a microform representation, which was even lower-level than an assembler-type representation.</em></p> <h3 id=flfriedman-1974>F.L.Friedman, 1974<a class=headerlink href=#flfriedman-1974 title="Permanent link">&para;</a></h3> <p>Friedman's PhD dissertation describes a decompiler used for the transfer of mini-computer operating systems within the same architectural class [ <a href=HistoryOfDecompilation1.html#RefFrie74>Frie74</a> ]. Four main phases are described: pre-processor, decompiler, code generator, and compiler.</p> <p>The pre-processor converts assembler code into a standard form (descriptive assembler language). The decompiler takes the standard assembler form, analyses it, and decompiles it into an internal representation, from which FRECL code is then generated by the code generator. Finally, a FRECL compiler compiles this program into machine code for another machine. FRECL is a high-level language for program transport and development; it was developed by Friedman, who also wrote a compiler for it. The decompiler used in this project was an adaptation of Housel's decompiler [ <a href=HistoryOfDecompilation1.html#RefHous73>Hous73</a> ].</p> <p>Two experiments were performed; the first one involved the transport of a small but self-contained portion of the IBM 1130 Disk Monitor System to Microdata 1600/21; up to 33% manual intervention was required on the input assembler programs. Overall, the amount of effort required to prepare the code for input to the transport system was too great to be completed in a reasonable amount of time; therefore, a second experiment was conducted. The second experiment decompiled Microdata 1621 operating system programs into FRECL and compiled them back again into Microdata 1621 machine code. Some of the resultant programs were re-inserted into the operating system and tested. On average, only 2% of the input assembler instructions required manual intervention, but the final machine program had a 194% increase in the number of machine instructions. See also [ <a href=HistoryOfDecompilation1.html#RefFS73>FS73</a> ].</p> <p><em>This dissertation is a first attempt at decompiling operating system code, and it illustrates the difficulties faced by the decompiler when decompiling machine-dependent code. Input programs to this transport system require a large amount of effort to be presented in the format required by the system, and the final produced programs appear to be inefficient; both in the size of the program and the time to execute many more machine instructions.</em></p> <h3 id=ultrasystems-1974>Ultrasystems, 1974<a class=headerlink href=#ultrasystems-1974 title="Permanent link">&para;</a></h3> <p>Hopwood reported on a decompilation project at Ultrasystems, Inc., in which he was a consultant for the design of the system [ <a href=HistoryOfDecompilation1.html#RefHopw78>Hopw78</a> ]. This decompiler was to be used as a documentation tool for the Trident submarine fire control software system. It took as input Trident assembler programs, and produced programs in the Trident High-Level Language (THLL) that was being developed at this company. Four main stages were distinguished: normalization, analysis, expression condensation, and code generation.</p> <p>The input assembler programs were normalized so that data areas were distinguished with pseudo-instructions. An intermediate representation was generated, and the data analyzed. Arithmetic and logical expressions were built during a process of expression condensation, and finally, the output high-level language program was generated by matching control structures to those available in THLL.</p> <p><em>This project attempts to document assembler programs by converting them into high-level language. The fact is, given the time constraints of the project, the expression condensation phase was not coded, and therefore the output programs were hard to read, as several instructions were required for a single expression.</em></p> <h3 id=vschneider-and-gwiniger-1974>V.Schneider and G.Winiger, 1974<a class=headerlink href=#vschneider-and-gwiniger-1974 title="Permanent link">&para;</a></h3> <p>Schneider and Winiger presented a notation for specifying the compilation and decompilation of high-level languages. By defining a context-free grammar for the compilation process (i.e. describe all possible 2-address object code produced from expressions and assignments), the paper shows how this grammar can be inverted to decompile the object code into the original source program [ <a href=HistoryOfDecompilation1.html#RefSchn74>Schn74</a> ]. Even more, an ambiguous compilation grammar will produce optimal object code, and will generate an unambiguous decompilation grammar. A case study showed that the object code produced by the Algol 60 constructs could not be decompiled deterministically. This work was part of a future decompiler, but further references in the literature about this work were not found.</p> <p><em>This work presents, in a different way, a syntax-oriented decompiler [ <a href=HistoryOfDecompilation1.html#REefHoll73>Holl73</a> ]; that is, a decompiler that uses pattern matching of a series of object instructions to reconstruct the original source program. In this case, the compilation grammar needs to be known in order to invert the grammar and generate a decompilation grammar. Note that no optimization is possible if it is not defined as part of the compilation grammar.</em></p> <h3 id=l-peter-deutsch-1977-1979>L Peter Deutsch 1977-1979<a class=headerlink href=#l-peter-deutsch-1977-1979 title="Permanent link">&para;</a></h3> <p>L. Peter Deutsch, using technology derived from his Ph.D thesis ("An Interactive Program Verifier", U.C. Berkeley, 1973), built a very small-scale instruction-set-retargetable decompiler (RMICRO) in Lisp at Xerox PARC. It was able to decompile binary code in 4 instruction sets (two microcodes, one minicomputer, and one bytecoded) into a C-like language, using Baker's algorithm (Journal of the <a href=ACM.html>ACM</a>, January 1977) to convert flowgraphs into if/while constructs. It never worked very well, and was not eveloped further. Peter is known for work on Lisp systems in the '70s, and later work on Ghostscript and just-in-time compilation for Smalltalk.</p> <h3 id=decompilation-of-polish-code-1977-1981-1988>Decompilation of Polish code, 1977, 1981, 1988<a class=headerlink href=#decompilation-of-polish-code-1977-1981-1988 title="Permanent link">&para;</a></h3> <p>Two papers in the area of decompilation of Polish code into Basic code are found in the literature. The problem arises in connection with highly interactive systems, where a fast response is required to every input from the user. The user's program is kept in an intermediate form, and then ``decompiled'' each time a command is issued. An algorithm for the translation of reverse Polish notation to expressions is given in [ <a href=HistoryOfDecompilation1.html#RefBalb79>Balb79</a> ].</p> <p>The second paper presents the process of decompilation as a two step problem: the need to convert machine code to Polish representation, and the conversion of Polish code to source form. The paper concentrates on the second step of the decompilation problem, but yet claims to be decompiling Polish code to Basic code by means of a context-free grammar for Polish notation and a left-to-right or right-to-left parsing scheme [ <a href=HistoryOfDecompilation1.html#RefBert81>Bert81</a> ].</p> <p>This technique was recently used in a decompiler that converted reverse Polish code into spreadsheet expressions [ <a href=HistoryOfDecompilation1.html#RefMay88>May88</a> ]. In this case, the programmers of a product that included a spreadsheet-like component wanted to speed up the product by storing user's expressions in a compiled form, reverse Polish notation in this case, and decompile these expressions whenever the user wanted to see or modify them. Parentheses were left as part of the reverse Polish notation to reconstruct the exact same expression the user had input to the system.</p> <p><em>The use of the word decompilation in this sense is a misuse of the term. All that is being presented in these papers is a method for re-constructing or deparsing the original expression (written in Basic or Spreadsheet expressions) given an intermediate Polish representation of a program. In the case of the Polish to Basic translators, no explanation is given as to how to arrive at such an intermediate representation given a machine program.</em></p> <h3 id=glhopwood-1978>G.L.Hopwood, 1978<a class=headerlink href=#glhopwood-1978 title="Permanent link">&para;</a></h3> <p>Hopwood's PhD dissertation [ <a href=HistoryOfDecompilation1.html#RefHopw78>Hopw78</a> ] describes a 7-step decompiler designed for the purposes of transferability and documentation. It is stated that the decompilation process can be aided by manual intervention or other external information.</p> <p>The input program to the decompiler is formatted by a preprocessor, then loaded into memory, and a control flow graph of the program is built. The nodes of this graph represent one instruction. After constructing the graph, control patterns are recognized, and instructions that generate a goto statement are eliminated by the use of either node splitting or the introduction of synthetic variables. The source program is then translated into an intermediate machine independent code, and analysis of variable usage is performed on this representation in order to find expressions and eliminate unnecessary variables by a method of forward substitution. Finally, code is generated for each intermediate instruction, functions are implemented to represent operations not supported by the target language, and comments are provided. Manual intervention was required to prepare the input data, provide additional information that the decompiler needed during the translation process, and to make modifications to the target program.</p> <p>An experimental decompiler was written for the Varian Data machines 620/i. It decompiled assembler into MOL620, a machine-oriented language developed at University of California at Irvine by M.D.Hopwood and the author. The decompiler was tested with a large debugger program, Isadora, which was written in assembler. The generated decompiled program was manually modified to recompile it into machine code, as there were calls to interrupt service routines, self-modifying code, and extra registers used for subroutine calls. The final program was better documented than the original assembler program.</p> <p><em>The main drawbacks of this research are the granularity of the control flow graph and the use of registers in the final target program. In the former case, Hopwood chose to build control flow graphs that had one node per instruction; this means that the size of the control flow graph is quite large for large programs, and there is no benefit gained as opposed to using nodes that are basic blocks (i.e. the size of the nodes is dependent on the number of changes of flow of control). In the latter case, the MOL620 language allows for the use of machine registers, and sample code illustrated in Hopwood's dissertation shows that registers were used as part of expressions and arguments to subroutine calls. The concept of registers is not a high-level concept available in high-level languages, and it should not be used if wanting to generate high-level code.</em></p> <h3 id=daworkman-1978>D.A.Workman, 1978<a class=headerlink href=#daworkman-1978 title="Permanent link">&para;</a></h3> <p>This work describes the use of decompilation in the design of a high-level language suitable for real time training device systems, in particular the F4 trainer aircraft [ <a href=HistoryOfDecompilation1.html#RefWork78>Work78</a> ]. The operating system of the F4 was written in assembler, and it was therefore the input language to this decompiler. The output language was not determined as this project was to design one, thus code generation was not implemented.</p> <p>Two phases of the decompiler were implemented: the first phase, which mapped the assembler to an intermediate language and gathered statistics about the source program, and the second phase, which generated a control flow graph of basic blocks, classified the instructions according to their probable type, and analyzed the flow of control in order to determine high-level control structures. The results indicated the need of a high-level language that handled bit strings, supported looping and conditional control structures, and did not require dynamic data structures or recursion.</p> <p><em>This work presents a novel use of decompilation techniques, although the input language was not machine code but assembler. A simple data analysis was done by classifying instructions, but did not attempt to analyze them completely as there was no need to generate high-level code. The analysis of the control flow is complete and considers 8 different categories of loops and 2-way conditional statements.</em></p> <h2 id=history-1980-1999>History: 1980-1999<a class=headerlink href=#history-1980-1999 title="Permanent link">&para;</a></h2> <h3 id=zebra-1981>Zebra, 1981<a class=headerlink href=#zebra-1981 title="Permanent link">&para;</a></h3> <p>The Zebra prototype was developed at the Naval Underwater Systems Centre in an attempt to achieve portability of assembler programs. Zebra took as input a subset of the ULTRA/32 assembler, called AN/UYK-7, and produced assembler for the PDP11/70. The project was described by D.L.Brinkley in [ <a href=HistoryOfDecompilation2.html#RefBrin81>Brin81</a> ].</p> <p>The Zebra decompiler was composed of 3 passes: a lexical and flow analysis pass, which parsed the program and performed control flow analysis in the graph of basic blocks. The second pass was concerned with the translation of the program to an intermediate form, and the third pass simplified the intermediate representation by eliminating extraneous loads and stores, in much the same way described by Housel [ <a href=HistoryOfDecompilation2.html#RefHous73>Hous73</a> , <a href=HistoryOfDecompilation2.html#RefHous73b>Hous73b</a> ]. It was concluded that it was hard to capture the semantics of the program and that decompilationwas economically impractical, but it could aid in the transportation process.</p> <p><em>This project made use of known technology to develop a decompiler of assembler programs. No new concepts were introduced by this research, but it raised the point that decompilation is to be used as a tool to aid in the solution of a problem, but not as tool that will give all solutions to the problem, given that a 100% correct decompiler cannot be built.</em></p> <h3 id=decompilation-of-dml-programs-1982>Decompilation of DML programs, 1982<a class=headerlink href=#decompilation-of-dml-programs-1982 title="Permanent link">&para;</a></h3> <p>A decompiler of database code was designed to convert a subset of Codasyl DML programs, written with procedural operations, into a relational system with a nonprocedural query specification. An Access Path Model is introduced to interpret the semantic accesses performed by the program. In order to determine how FIND operations implement semantic accesses, a global data flow reaching analysis is performed on the control flow graph, and operations are matched to templates. The final graph structures are remapped into a relational structure. This method depends on the logical order of the objects and a standard ordering of the DML statements [ <a href=HistoryOfDecompilation2.html#RefKatz82>Katz82</a> ].</p> <p>Another decompiler of database code was proposed to decompile well-coded application programs into a proposed semantic representation is described in [ <a href=HistoryOfDecompilation2.html#RefDors82>Dors82</a> ]. This work was induced by changes in the use requirements of a Database Management System (DBMS), where application programs were written in Cobol-DML. A decompiler of Cobol-DML programs was written to analyse and convert application programs into a model and schema-independent representation. This representation was later modified or restructured to account for database changes. Language templates were used to match against key instructions of a Cobol-DML programs.</p> <p><em>In the context of databases, decompilation is viewed as the process of grouping a sequence of statements which represent a query into another (nonprocedural) specification. Data flow analysis is required, but all other stages of a decompiler are not implemented for this type of application.</em></p> <h3 id=forth-decompiler-1982-1984>Forth Decompiler, 1982, 1984<a class=headerlink href=#forth-decompiler-1982-1984 title="Permanent link">&para;</a></h3> <p>A recursive Forth decompiler is a tool that scans through a compiled dictionary entry and decompiles words into primitives and addresses [ <a href=HistoryOfDecompilation2.html#RefDud82>Dudl82</a> ]. Such a decompiler is considered one of the most useful tools in the Forth toolbox [ <a href=HistoryOfDecompilation2.html#RefHill84>Hill84</a> ]. The decompiler implements a recursive descent parser so that decompiled words can be decompiled in a recursive fashion.</p> <p><em>These works present a deparsing tool rather than a decompiler. The tool recursively scans through a dictionary table and returns the primitives or addresses associated with a given word.</em></p> <h3 id=dataflex-decompilers-1984>Dataflex Decompilers, 1984<a class=headerlink href=#dataflex-decompilers-1984 title="Permanent link">&para;</a></h3> <p>DataFlex is a macro-based language. Some macros include over 80 DataFlex commands in one macro command. The Database Managers company Dataflex Decompilers have the capability of recovering the highest-level macro command instead of the low-level commands that compose such a macro. The techniques used in this decompiler include pattern matching and the recovery of control structures such as if's and loops. The generated code is functionally equivalent to the original source and is guaranteed to be recompilable without changes.</p> <h3 id=software-transport-system-1985>Software Transport System, 1985<a class=headerlink href=#software-transport-system-1985 title="Permanent link">&para;</a></h3> <p>C.W.Yoo describes an automatic Software Transport System (STS) that moves assembler code from one machine to another. The process involves the decompilation of an assembler program for machine m1 to a high-level language, and the compilation of this program in a machine m2 to assembler. An experimental decompiler was developed on the Intel 8080 architecture; it took as input assembler programs and produced PL/M programs. The recompiled PL/M programs were up to 23% more efficient than their assembler counterpart. An experimental STS was developed to develop a C cross-compiler for the Z-80 processor. The project encountered problems in the lack of data type in the STS [ <a href=HistoryOfDecompilation2.html#RefWoo85>Woo85</a> ].</p> <p>The STS took as input an assembler program for machine m1 and an assembler grammar for machine m2, and produced an assembler program for machine m2. The input grammar was parsed and produced tables used by the abstract syntax tree parser to parse the input assembler program and generate an abstract syntax tree (AST) of the program. This AST was the input to the decompiler, which then performed control and data flow analyses, in much the same way described by Hollander [ <a href=HistoryOfDecompilation2.html#RefHoll73>Holl73</a> ], Friedman [ <a href=HistoryOfDecompilation2.html#RefFrie74>Frie74</a> ], and Barbe [ <a href=HistoryOfDecompilation2.html#RefBarb74>Barb74</a> ], and finally generated high-level code. The high-level language was then compiled for machine m2.</p> <p><em>This work does not present any new research into the decompilation area, but it does present a novel approach to the transportation of assembler programs by means of a grammar describing the assembler instructions of the target architecture.</em></p> <h3 id=decomp-1988>Decomp, 1988<a class=headerlink href=#decomp-1988 title="Permanent link">&para;</a></h3> <p>See <a href=DecompDecompiler.html>DecompDecompiler</a> for information about a decompiler for the Vax BSD 4.2 which took as input object files, and produced C-like programs.</p> <h3 id=fermat-1989-to-present><a href=FermaT.html>FermaT</a>, 1989 to present<a class=headerlink href=#fermat-1989-to-present title="Permanent link">&para;</a></h3> <p><a href=MartinWard.html>Martin Ward</a>'s PhD thesis [ <a href=HistoryOfDecompilation2.html#RefWar89>War89</a> ] is about formal, provable program transformations. He has written a program transformation engine called <a href=FermaT.html>FermaT</a> which facilitates forward and reverse engineering from assembly language to specifications and back again. The technology is marketed through the company <a href=SoftwareMigrations.html>SoftwareMigrations</a>. Real-world decompilation of assembly language programs (such as IBM-370 assembler) to C [ <a href=HistoryOfDecompilation2.html#RefWar99>War99</a> ] and <a href=COBOL.html>COBOL</a> have been performed, and recently from 80186 assembly language to C [ <a href=HistoryOfDecompilation2.html#RefSML03>SML03</a> ].</p> <h3 id=exe2c-1990>exe2c, 1990<a class=headerlink href=#exe2c-1990 title="Permanent link">&para;</a></h3> <p>The Austin Code Works sponsored the development of the exe2c decompiler, targetted at the PC compatible family of computers running the DOS operating system [ <a href=HistoryOfDecompilation2.html#RefAust91>Aust91</a> ]. The project was announced in April 1990 [ <a href=HistoryOfDecompilation2.html#RefGuth90>Guth90</a> ], tested by about 20 people, and it was decided that it needed some more work to decompile in C. A year later, the project reached a beta operational level [ <a href=HistoryOfDecompilation2.html#RefGuth91a>Guth91a</a> ], but was never finished [ <a href=HistoryOfDecompilation2.html#RefGuth91b>Guth91b</a> ]. I (<a href=CristinaCifuentes.html>Cristina Cifuentes</a>) was a beta tester of this release.</p> <p>exe2c is a multipass decompiler that consists of 3 programs: e2a, a2aparse, and e2c. e2a is the disassembler. It converts executable files to assembler, and produces a commented assembler listing as well. e2aparse is the assembler to C front-end processor, which analyzes the assembler file produced by e2a and generates .cod and .glb files. Finally, the e2c program translates the files prepared by a2aparse and generates pseudo-C. An integrated environment, envmnu, is also provided.</p> <p>Programs decompiled by exe2c make use of a header file that defines registers, types and macros. The output C programs are hard to understand because they rely on registers and condition codes (represented by Boolean variables). Normally, one machine instruction is decompiled into one or more C instructions that perform the required operation on registers, and set up condition codes if required by the instruction. Expressions and arguments to subroutines are not determined, and a local stack is used for the final C programs. It is obvious from this output code that a data flow analysis was not implemented in exe2c. This decompiler has implemented a control flow analysis stage; looping and conditional constructs are available. The choice of control constructs is generally adequate. Case tables are not detected correctly, though. The number and type of procedures decompiled shows that all library routines, and compiler start-up code and runtime support routines found in the program are decompiled. The nature of these routines is normally low-level, as they are normally written in assembler. These routines are hard to decompile as, in most cases, there is no high-level counterpart (unless it is low-level type C code).</p> <p><em>This decompiler is a first effort in many years to decompile executable files. The results show that a data flow analysis and heuristics are required to produce better C code. Also, a mechanism to skip all extraneous code introduced by the compiler and to detect library subroutines would be beneficial.</em></p> <h3 id=plm-80-decompiler-1991>PLM-80 Decompiler, 1991<a class=headerlink href=#plm-80-decompiler-1991 title="Permanent link">&para;</a></h3> <p>The Information Technology Division of the Australian Department of Defence researched into decompilation for defence applications, such as maintenance of obsolete code, production of scientific and technical intelligence, and assessment of systems for hazards to safety or security. This work was described by S.T. Hood in [ <a href=HistoryOfDecompilation2.html#RefHood91>Hood91</a> ].</p> <p>Techniques for the construction of decompilers using definite-clause grammars, an extension of context-free grammars, in a Prolog environment are described. A Prolog database is used to store the initial assembler code and the recognised syntactic structures of the grammar. A prototype decompiler for Intel 8085 assembler programs compiled by a PLM-80 compiler was written in Prolog. The decompiler produced target programs in Small-C, a subset of the C language. The definite-clause grammar given in this report was capable of recognizing if-then control structures, and while loops, as well as static (global) and automatic (local) variables of simple types (i.e. character, integers, and longs). A graphical user interface was written to display the assembler and pseudo-C programs, and to enable the user to assign variable names, and comments. This interface also asked the user for the entry point to the main program, and allowed him to select the control construct to be recognized.</p> <p><em>The analysis performed by this decompiler is limited to the recognition of control structures and simple data types. No analysis on the use of registers is done or mentioned. Automatic variables are represented by an indexed variable that represents the stack. The graphical interface helps the user document the decompiled program by means of comments and meaningful variable names. This analysis does not support optimized code.</em></p> <h3 id=j-ogorman-phd-thesis-1991>J. O'Gorman PhD thesis, 1991<a class=headerlink href=#j-ogorman-phd-thesis-1991 title="Permanent link">&para;</a></h3> <p>The Systematic Decompilation thesis by John O'Gorman [ <a href=HistoryOfDecompilation2.html#RefOGor91>OGor91</a> ], University of Limerick, describes a pattern matching technique used for decompiling VAX binaries into Pascal source code. The technique requires the availability of the compiler used, performs a coverage of constructs available in the language, and creates small test programs that use the constructs, in order to derive the patterns of machine code used for each high-level construct. When decompiling a Pascal executable, the patterns are matched to determine which Pascal construct to recreated. Unoptimized code is used.</p> <p>The thesis is available for downloading (ftp) in postscript format: <a href=https://web.archive.org/web/20250214145422/ftp://www.csis.ul.ie/techrpts/ul-91-12.ps>ftp://www.csis.ul.ie/techrpts/ul-91-12.ps</a>.</p> <h3 id=decompiler-compiler-1991-1994>Decompiler compiler, 1991-1994<a class=headerlink href=#decompiler-compiler-1991-1994 title="Permanent link">&para;</a></h3> <p>A decompiler compiler is a tool that takes as input a compiler specification and the corresponding portions of object code, and returns the code for a decompiler; i.e. it is an automatic way of generating decompilers, much in the same way that yacc is used to generate compilers [ <a href=HistoryOfDecompilation2.html#RefBowe91a>Bowe91a</a>, <a href=HistoryOfDecompilation2.html#RefBowe91b>Bowe91b</a>, <a href=HistoryOfDecompilation2.html#RefBreu94>Breu94</a> ].</p> <p>Two approaches are described to generate such a decompiler compiler: a logic and a functional programming approach. The former approach makes use of the bidirectionality of logic programming languages such as Prolog, and runs the specification of the compiler backwards to obtain a decompiler [Bowe91a, Bowe91b, Bowe93b]. In theory this is correct, but in practice this approach is limited to the implementation of the Prolog interpreter, and therefore problems of strictness and reversibility are encountered [ <a href=HistoryOfDecompilation2.html#RefBreu92>Breu92</a>, <a href=HistoryOfDecompilation2.html#RefBreu93>Breu93</a> ]. The latter approach is based on the logic approach but makes use of lazy functional programming languages like Haskell, to generate a more efficient decompiler [ <a href=HistoryOfDecompilation2.html#RefBowe91>aBowe91a</a>, <a href=HistoryOfDecompilation2.html#RefBowe91b>Bowe91b</a>, <a href=HistoryOfDecompilation2.html#RefBowe93b>Bowe93b</a> ]. Even if a non-lazy functional language is to be used, laziness can be simulated in the form of objects rather than lists.</p> <p>The decompiler produced by a decompiler compiler will take as input object code and return a list of source codes that can be compiled to the given object code. In order to achieve this, an enumeration of all possible source codes would be required, given a description of an arbitrary inherited attribute grammar. It is proved that such an enumeration is equivalent to the Halting Problem [ <a href=HistoryOfDecompilation2.html#RefBreu92>Breu92</a>, <a href=HistoryOfDecompilation2.html#RefBreu93>Breu93</a> ], and is therefore non-computable. Even further, there is no computable method which takes an attribute grammar description and decides whether or not the compiled code will give a terminating enumeration for a given value of the attribute [ <a href=HistoryOfDecompilation2.html#RefBreu92>Breu92</a>, <a href=HistoryOfDecompilation2.html#RefBreu93>Breu93</a> ], so it is not straightforward which grammars can be used. Therefore, the class of grammars acceptable to this method needs to be restricted to those that produce a complete enumeration, such as non left-recursive grammars.</p> <p>An implementation of this method was firstly done for a subset of an Occam-like language using a functional programming language. The decompiler grammar was an inherited attribute grammar which took the intended object code as an argument [ <a href=HistoryOfDecompilation2.html#RefBreu92>Breu92</a>, <a href=HistoryOfDecompilation2.html#RefBreu93>Breu93</a> ]. A Prolog decompiler was also described based on the compiler specification. This decompiler applied the clauses of the compiler in a selective and ordered way, so that the problem of non-termination would not be met, and only a subset of the source code programs would be returned (rather than an infinite list) [ <a href=HistoryOfDecompilation2.html#RefBowe91c>Bowe91c</a>, <a href=HistoryOfDecompilation2.html#RefBowe93>Bowe93</a> ]. Recently, this method made use of an imperative programming language, C++, due to the inefficiencies of the functional and logic approach. In this prototype, C++ object's were used as lazy lists, and a set of library functions was written to implement the operators of the intermediate representation used [ <a href=HistoryOfDecompilation2.html#RefBreu94>Breu94</a> ]. Problems with optimized code have been detected.</p> <p><em>As illustrated by this research, decompiler compilers can be constructed automatically if the set of compiler specifications and object code produced for each clause of the specification is known. In general, this is not the case as compiler writers do not disclose their compiler specifications. Only customized compilers and decompilers can be built by this method. It is also noted that optimizations produced by the optimization stage of a compiler are not handled by this method, and that real executable programs cannot be decompiled by the decompilers generated by the method described. The problem of separating instructions from data is not addressed, nor is the problem of determining the data types of variables used in the executable program. In conclusion, decompiler compilers can be generated automatically if the object code produced by a compiler is known, but the generated decompilers cannot decompile arbitrary executable programs.</em></p> <h3 id=8086-c-decompiling-system-1991-1993>8086 C Decompiling System, 1991-1993<a class=headerlink href=#8086-c-decompiling-system-1991-1993 title="Permanent link">&para;</a></h3> <p>This decompiler takes as input executable files from a DOS environment and produces C programs. The input files need to be compiled with Microsoft C version 5.0 in the small memory model [ <a href=HistoryOfDecompilation2.html#RefFuan93>Fuan93</a> ]. Five phases were described: recognition of library functions, symbolic execution, recognition of data types, program transformation, and C code generation. The recognition of library functions and intermediate language was further described in [ <a href=HistoryOfDecompilation2.html#RefFuan91>Fuan91</a>, <a href=HistoryOfDecompilation2.html#RefHung91>Hung91</a> ].</p> <p>The recognition of library functions for Microsoft C was done to eliminate subroutines that were part of a library, and therefore produce C code for only the user routines. A table of C library functions is built-into the decompiling system. For each library function, its name, characteristic code (sequence of instructions that distinguish this function from any other function), number of instructions in the characteristic code, and method to recognize the function were stored. This was done manually by the decompiler writer. The symbolic execution translated machine instructions to intermediate instructions, and represented each instruction in terms of its symbolic contents. The recognition of data types is done by a set of rules for the collection of information on different data types and analysis rules to determine the data type in use. The program transformation transforms storage calculation into address expressions, e.g. array addressing. Finally, the C code generator transforms the program structure by finding control structures, and generates C code.</p> <p>8086C seems to be based on a Unix/68000 decompiler called 68000C [ <a href=HistoryOfDecompilation2.html#RefZong88>Zong88</a> ]. See also <a href=HistoryOfDecompilation2.html#TopicDECLER>DECLER</a>.</p> <p><em>This decompiling system makes use of library function recognition to generate more readable C programs. The method of library recognition is hand-crafted, and therefore inefficient if other versions of the compiler, other memory models, or other compilers were used to compile the original programs. The recognition of data types is a first attempt to recognize types of arrays, pointers and structures, but not much detail is given in the paper. No description is given as to how an address expression is reached in the intermediate code, and no examples are given to show the quality of the final C programs.</em></p> <h3 id=alpha-axp-migration-tools-1993>Alpha AXP Migration Tools, 1993<a class=headerlink href=#alpha-axp-migration-tools-1993 title="Permanent link">&para;</a></h3> <p>When Digital Equipment Corporation designed the Alpha AXP architecture, the AXP team got involved in a project to run existing VAX and MIPS code on the new Alpha AXP computers. They opted for a binary translator which would convert a sequence of instructions of the old architecture into a sequence of instructions of the new architecture. The process needed to be fully automatic and to cater for code created or modified during execution. Two parts to the migration process were defined: a binary translation, and a runtime environment [ <a href=HistoryOfDecompilation2.html#RefSite93>Site93</a> ].</p> <p>The binary translation phase took binary programs and translated them into AXP opcodes. It made use of decompilation techniques to understand the underlying meaning of the machine instructions. Condition code usage analysis was performed as these conditions do not exist on the Alpha architecture. The code was also analyzed to determine function return values and find bugs (e.g. uninitialized variables). MIPS has standard library routines which are embedded in the binary program. In this case, a pattern matching algorithm was used to detect routines that were library routines, such routines were not analysed but replaced by their name. Idioms were also found and replaced by an optimal instruction sequence. Finally, code was generated in the form of AXP opcodes. The new binary file had both, the new code and the old code.</p> <p>The runtime environment executes the translated code and acts as a bridge between the new and old operating systems (e.g. different calling standards, exception handling). It had a built-in interpreter of old code to run old code not discovered or nonexistent at translation time. This was possible because the old code was also saved as part of the new binary file.</p> <p>Two binary translators were written: VEST, to translate from the OpenVMS VAX system to the OpenVMS AXP system, and mx, to translate ULTRIX MIPS images to DEC OSF/1 AXP images. The runtime environments for these translators were TIE and mxr respectively.</p> <p><em>This project illustrates the use of decompilation techniques in a modern translation system. It proved successful for a large class of binary programs. Some of the programs that could not be translated were programs that were technically infeasible to translate, such as programs that use privileged opcodes, or run with superuser privileges.</em></p> <h3 id=sourceprom-comparator-1993>Source/PROM Comparator, 1993<a class=headerlink href=#sourceprom-comparator-1993 title="Permanent link">&para;</a></h3> <p>A tool to demonstrate the equivalence of source code and PROM contents was developed at the Nuclear Electric plc, UK, to verify the correct translation of PL/M-86 programs into PROM programs executed by safety critical computer controlled systems [ <a href=HistoryOfDecompilation2.html#RefPave93>Pave93</a> ].</p> <p>Three stages are identified: the reconstitution of object code files from the PROM files, the disassembly of object code to an assembler-like form with help from a name-table built up from the source code, and decompilation of assembler programs and comparison with the original source code. In the decompiling stage, it was noted that it was necessary to eliminate intermediate jumps, registers and stack operations, identify procedure arguments, resolve indexes of structures, arrays and pointers, and convert the expresssions to a normal form. In order to compare the original program and the decompiled program, an intermediate language was used. The source program was translated to this language with the use of a commercial product, and the output of the decompilation stage was written in the same language. The project proved to be a practical way of verifying the correctness of translated code, and to demonstrate that the tools used to create the programs (compiler, linker, optimizer) behave reliably for the particular safety system analyzed.</p> <p><em>This project describes a use of decompilation techniques, to help demonstrate the equivalence of high-level and low-level code in a safety-critical system. The decompilation stage performs much of the analysis, with help from a symbol table constructed from the original source program. The task is simplified by the knowledge of the compiler used to compile the high-level programs.</em></p> <h3 id=cristina-cifuentes-phd-thesis-reverse-compilation-techniques-1994><a href=CristinaCifuentes.html>Cristina Cifuentes</a>' PhD Thesis "Reverse Compilation Techniques", 1994<a class=headerlink href=#cristina-cifuentes-phd-thesis-reverse-compilation-techniques-1994 title="Permanent link">&para;</a></h3> <p>Considered by some to be the definitive work on general decompilation from binary files. You can download the thesis from <a href=CristinaCifuentes.html>Cristina Cifuentes</a>' page, as a compressed postscript file (474K). This work draws heavily on standard forward engineering techniques such as data flow analysis, applied to decompilation. Similarly, graph techniques are used to restructure the generated code into standard loops, conditional statements, and other high level constructs. Type recovery is limited to built-in types (no arrays or structures). Cristina demonstrated her techniques in a research prototype called <a href=https://web.archive.org/web/20250214145422/http://www.itee.uq.edu.au/~cristina/dcc.html>dcc</a>.</p> <p>After her PhD, Cristina worked for some years on <a href=/web/20250214145422/https://www.program-transformation.org/twiki/bin/view/Transform/BinaryTranslation.html>Binary Translation</a>, for example see the <a href=https://web.archive.org/web/20250214145422/http://www.itee.uq.edu.au/~cristina/uqbt.html>UQBT page</a>. Cristina is currently associate advisor for <a href=MikeVanEmmerik.html>Mike Van Emmerik</a>'s current PhD research, also on decompilation.</p> <h3 id=decler-decompiler-1995>DECLER Decompiler, 1995<a class=headerlink href=#decler-decompiler-1995 title="Permanent link">&para;</a></h3> <p>DECLER [ <a href=HistoryOfDecompilation2.html#RefDRM95>DRM95</a> ], [ <a href=HistoryOfDecompilation2.html#RefZong96>Zong96</a> ], [ <a href=HistoryOfDecompilation2.html#RefCL00>CL00</a> ] is a five stage decompiler, based on <a href=HistoryOfDecompilation2.html#TopicEightOhEightSix>8086C</a> and 68000C. The stages are disassembler, library function recogniser, symbolic executer, "AB transformer", and "C transformer". The AB transformer appears to be a formal transformation system that recovers types as a side effect. The C transformer is the structuring back end.</p> <h3 id=university-of-queensland-binary-translator-1997-2001>University of Queensland Binary Translator, 1997-2001<a class=headerlink href=#university-of-queensland-binary-translator-1997-2001 title="Permanent link">&para;</a></h3> <p>The University of Queensland Binary Translator (UQBT), 1997-2001 . This Binary Translator uses a standard C compiler as the "back end"; in other words, it emits C source code. However, this is not the same as a decompiler, where the goal is human readable high level code. As a result, UQBT can't be used in any of the applications that come under the heading of "comprehension aid" or "maintainable code". Work on UQBT was not completed, however it was capable of producing low level source code for moderate sized programs, such as the smaller SPEC benchmarks [ <a href=HistoryOfDecompilation2.html#RefCVE00>CVE00</a>, <a href=HistoryOfDecompilation2.html#RefCVEU99>CVEU+99</a> ].</p> <h3 id=a-mycrofts-type-reconstruction-for-decompilation-1999>A. Mycroft's Type Reconstruction for Decompilation, 1999<a class=headerlink href=#a-mycrofts-type-reconstruction-for-decompilation-1999 title="Permanent link">&para;</a></h3> <p>One of the hardest problems to solve in decompilation is that of recovering high-level data types from machine code in a correct way. Such types include structures, arrays and more. In this work, Alan Mycroft presents a system for infering high-level types from assembler-based (RTL) code [ <a href=HistoryOfDecompilation2.html#RefMycr99>Mycr99</a> ]. Alan's type inference system is based on Milner's work for ML. The paper presents a type system, the constraints on types and worked-through examples that include structures and arrays as part of their output. Experimental results for the system are not available.</p> <p>This is the best type system that I am aware of that currently deals with recoverying high-level data types in a machine-independent way, as it is based on RTLs and makes no unreasonable assumptions on the shape of the RTLs. Implementation results are needed in order to determine how feasible this system is in real practice.</p> <h2 id=history-2000-2007>History: 2000-2007<a class=headerlink href=#history-2000-2007 title="Permanent link">&para;</a></h2> <h3 id=university-of-londons-asm21toc-reverse-compiler-2000>University of London's Asm21toc reverse compiler, 2000.<a class=headerlink href=#university-of-londons-asm21toc-reverse-compiler-2000 title="Permanent link">&para;</a></h3> <p>This assembly language decompiler for Digital Signal Processing (DSP) code was written in a compiler-compiler called rdp [ <a href=HistoryOfDecompilation3.html#RefJSW00>JSW00</a> ]. The authors note that DSP is one of the last areas where assembly language is still commonly used. As usual, the decompilation from assembly language is considerably easier than from executable code; in fact the authors "doubt the usefulness" of decompiling from binary files.</p> <h3 id=proof-directed-de-compilation-of-low-level-code-2001>Proof-Directed De-compilation of Low-Level Code, 2001.<a class=headerlink href=#proof-directed-de-compilation-of-low-level-code-2001 title="Permanent link">&para;</a></h3> <p>Katsumata and Ohori published a paper [ <a href=HistoryOfDecompilation3.html#RefKO01>KO01</a> ] on decompilation based on proof theoretical methods. The input is Jasmin, essentially Java assembly language. The output is an ML-like simply typed functional language. Their example shows an iterative implementation of the factorial function transformed into two functions (an equivalent recursive implementation). Their approach is to treat each instruction as a constructive proof representing its computation. While not immediately applicable to a general decompiler, their work may have application where proof of correctness (usually of a compilation) is required.</p> <p>In [ <a href=HistoryOfDecompilation3.html#RefMyc01>Myc01</a> ], Mycroft compares his Type-Based decompilation with this work. Structuring to loops and conditionals is not attempted by either system. He concludes that the two systems produce very similar results in the areas where they overlap, but that they have different strengths and weaknesses.</p> <h3 id=computer-security-analysis-through-decompilation-and-high-level-debugging-2001>Computer Security Analysis through Decompilation and High-Level Debugging, 2001.<a class=headerlink href=#computer-security-analysis-through-decompilation-and-high-level-debugging-2001 title="Permanent link">&para;</a></h3> <p>Cifuentes et al suggested dynamic decompilation as a way to provide a powerful tool for security work. The main idea is that the security analyst is only interested in one small piece of code at one time, and so high level code could be generated "on the fly". One problem with traditional (static) decompilation is that it is difficult to determine the range of possible values of variables; by contrast, a dynamic decompiler can provide at least one value (the current value) with no effort [ <a href=HistoryOfDecompilation3.html#RefCWVE01>CWVE01</a> ].</p> <h3 id=type-propagation-in-ida-pro-disassembler-2001>Type Propagation in IDA Pro Disassembler, 2001.<a class=headerlink href=#type-propagation-in-ida-pro-disassembler-2001 title="Permanent link">&para;</a></h3> <p>Guilfanov describes the type propagation system in the popular disassembler IDA Pro <a href=https://web.archive.org/web/20250212082115/http://www.datarescue.com/idabase/ >Ida Pro</a>. The types of parameters to library calls are captured from system header files. The parameter types for commonly used libraries are saved in files called type libraries. Assignments to parameter locations are annotated with comments with the name and type of the parameter. This type information is propagated to other parts of the disassembly, including all known callers. At present, no attempt is made to find the types for other variables not associated with the parameters of any library calls [ <a href=HistoryOfDecompilation3.html#RefGui01>Gui01</a> ].</p> <h3 id=disc-by-satish-kumar-2001><a href=DisC.html>DisC</a>, by Satish Kumar, 2001.<a class=headerlink href=#disc-by-satish-kumar-2001 title="Permanent link">&para;</a></h3> <p>This decompiler is designed to read only programs written in Turbo C version 2.0 or 2.01; it is an example of a compiler specific decompiler. There is no significant advantage to this approach, since general techniques are not much more difficult to implement. It is an interesting observation that since most aspects of decompilation are ultimately pattern matching in some sense, the difference between pattern matching decompilers and general ones is essentially one of the generality of the patterns. <a href=https://web.archive.org/web/20250212082115/http://www.debugmode.com/dcompile/disc.htm>http://www.debugmode.com/dcompile/disc.htm</a>.</p> <h3 id=ndcc-decompiler-2002>ndcc decompiler, 2002.<a class=headerlink href=#ndcc-decompiler-2002 title="Permanent link">&para;</a></h3> <p>AndrÔøΩ Janz modified the dcc decompiler to read 32-bit Windows Portable Executable (PE) files. The intent was to use the modified decompiler to analyse malware. The author states that a rewrite would be needed to fully implement the 80386 instruction set. Even so, reasonable results were obtained, while retaining dcc's severe limitations [ <a href=HistoryOfDecompilation3.html#RefJan02>Jan02</a> ].</p> <h3 id=the-anatomizer-decompiler-circa-2002>The Anatomizer Decompiler, circa 2002.<a class=headerlink href=#the-anatomizer-decompiler-circa-2002 title="Permanent link">&para;</a></h3> <p>K. Morisada released a decompiler for Windows 32-bit programs, which appears to be comparable in capability to the REC compiler for that platform. See also <a href=AnatomizerDecompiler.html>AnatomizerDecompiler</a> and <a href=https://web.archive.org/web/20250212082115/http://jdi.at.infoseek.co.jp/ >http://jdi.at.infoseek.co.jp</a>.</p> <h3 id=analysis-of-virtual-method-invocation-for-binary-translation-2002>Analysis of Virtual Method Invocation for Binary Translation, 2002.<a class=headerlink href=#analysis-of-virtual-method-invocation-for-binary-translation-2002 title="Permanent link">&para;</a></h3> <p>TrÔøΩger and Cifuentes show a method of analysing indirect call instructions. If such a call implements a virtual method call and is correctly identified, various important aspects of the call are extracted. The technique as presented is limited to one basic block; as a result, it fails for some less common cases. [ <a href=HistoryOfDecompilation3.html#RefTC02>TC02</a> ].</p> <h3 id=boomerang-2002>Boomerang, 2002.<a class=headerlink href=#boomerang-2002 title="Permanent link">&para;</a></h3> <p>This is an open source decompiler, with several front ends (two are well developed) and a C back end. It uses an internal representation based on the Static Single Assignment form, and pioneers dataflow-based type analysis. At the time of writing, it is still limited to quite small (toy) binary programs. <a href=https://web.archive.org/web/20250212082115/http://boomerang.sourceforge.net/ >http://boomerang.sourceforge.net</a>.</p> <h3 id=desquirr-2002>Desquirr, 2002.<a class=headerlink href=#desquirr-2002 title="Permanent link">&para;</a></h3> <p>This is an IDA Pro Plugin, written by David Eriksson as part of his Master's thesis. It decompiles one function at a time to the IDA output window. While not intended to be a serious decompiler, it illustrates what can be done with the help of a powerful disassembler and about 5000 lines of C++ code. Because a disassembler does not carry semantics for machine instructions, each supported processor requires a module to decode instruction semantics and addressing modes. The X86 and ARM processors are supported. Conditionals and loops are emitted as gotos, there is some simple switch analysis, and some recovery of parameters and returns is implemented. <a href=https://web.archive.org/web/20250212082115/http://desquirr.sourceforge.net/desquirr>http://desquirr.sourceforge.net/desquirr</a>.</p> <h3 id=analyzing-memory-accesses-in-x86-executables-2004>Analyzing Memory Accesses in x86 Executables, 2004.<a class=headerlink href=#analyzing-memory-accesses-in-x86-executables-2004 title="Permanent link">&para;</a></h3> <p>Balakrishnan and Reps from the University of Wisconsin have developed a framework for analysing binary programs that they call Codesurfer/x86. The aim is to produce intermediate representations that are similar to those that can be created for a program written in a high-level language. The binary is first disassembled with the IDA Pro disassembler. A plug-in for IDA Pro called Connector, provided by <a href=https://web.archive.org/web/20250212082115/http://www.grammatech.com/ >Grammatech Inc</a>, interfaces to the rest of the tool. Value-set Analysis (VSA) is used to produce an intermediate representation, which is presented in a source code analysis tool called <a href=https://web.archive.org/web/20250212082115/http://www.grammatech.com/products/codesurfer/overview.html>CodeSurfer</a> (sold separately by Grammatech Inc for C/C++ source code analysis) [ <a href=HistoryOfDecompilation3.html#RefBR04>BR04</a>, <a href=HistoryOfDecompilation3.html#RefRBLT05>RBLT05</a> ]. Codesurfer/x86 may be <a href=https://web.archive.org/web/20250212082115/http://www.grammatech.com/research/cs-x86/ >commercially available soon</a>.</p> <h3 id=r-falkes-type-analysis-for-decompilers-2004>R. Falke's Type Analysis for Decompilers, 2004<a class=headerlink href=#r-falkes-type-analysis-for-decompilers-2004 title="Permanent link">&para;</a></h3> <p>Raimar Falke, in his Diploma Thesis [ <a href=HistoryOfDecompilation3.html#RefFal04>Fal04</a> ] (German) for the Technical University of Dresden, implemented an adaption of Mycroft's type constraint theory in a decompiler called YaDeC. He extended it to handle arrays. To keep the project manageable, he used objdump for the front end, ignored floating point types, assumed only stack parameters, and so on. An English translation of the paper's summary can be found in <a href=FalkeDiplomaSummary.html>FalkeDiplomaSummary</a>.</p> <h3 id=andromeda-decompiler-2004-2005>Andromeda Decompiler, 2004-2005.<a class=headerlink href=#andromeda-decompiler-2004-2005 title="Permanent link">&para;</a></h3> <p>Andrey Shulga wrote a decompiler for Windows x86 and C. The decompiler itself was never released, however a GUI program for manipulating the IR generated by the compiler is available at the author's web site [ <a href=HistoryOfDecompilation3.html#RefShu04>Shu04</a> ]. Only an x86 front end is written at present, and only a C/C++ back end, although the decompiler is claimed to be capable of other front and back ends. The output for the provided demonstration IR is extremely impressive, but it is not clear whether the IR is largely automatically generated by the decompiler, or hand edited. The web page has been inactive since May 2005.</p> <h3 id=hex-rays-decompiler-plugin-2007>Hex Rays Decompiler Plugin, 2007.<a class=headerlink href=#hex-rays-decompiler-plugin-2007 title="Permanent link">&para;</a></h3> <p>Ilfak Guilfanov, author of the IDA Pro disassembler, released a commercial decompiler plugin for IDA Pro [ <a href=HistoryOfDecompilation3.html#RefGui07a>Gui07a</a>, <a href=HistoryOfDecompilation3.html#RefGui07b>Gui07b</a> ]. This plugin adds a decompiler view to the other views available in the interactive disassembler. One function is shown at a time; most functions decompile in a fraction of a second to a quite C-like output. The author stresses that output is not designed for re-compilation, only for more rapid comprehension of what the function is doing. The output includes compound conditionals (with || and &amp;&amp;), loops (for, while, break, etc), and function parameters and returns. There is also an <a href=API.html>API</a> which gives access to the decompiler's IR, allowing custom analyses if desired. At this stage, only the x86 architecture is supported. The decompiler relies on the disassembler (and possibly manual intervention) to separate code from data and to identify functions.</p> <h3 id=static-single-assignment-for-decompilation-2007>Static Single Assignment for Decompilation, 2007.<a class=headerlink href=#static-single-assignment-for-decompilation-2007 title="Permanent link">&para;</a></h3> <p>Mike Van Emmerik completed this PhD theses at the University of Queensland in October 2007 [ <a href=HistoryOfDecompilation3.html#RefVE07>VE07</a> ]. The main theme is how the SSA form enables various aspects of decompilation to be more readily analysed, although this leads to other topics such as type analysis and the analysis of indirect jumps and calls. An industry case study is discussed. Although considerable progress is made, many problems still remain, particularly related to alias analysis. There is a chapter of results, using the Boomerang open source decompiler. A new algorithm for finding preserved locations in procedures in the presence of recursion is given. There is a comprehensive glossary of terms, history, comparison with Java decompilers, a survey of compiler infrastructures that may be suitable for decompilation, and the problems faced by decompilers are summarised in terms of separation problems (code from data, pointers from constants, and original from offset pointers).</p> <h2 id=references>References<a class=headerlink href=#references title="Permanent link">&para;</a></h2> <p>Hals62</p> <p>M.H. Halstead. Machine-independent computer programming, Chapter 11, pages 143-150. Spartan Books, 1962.</p> <p>Hals67</p> <p>M.H. Halstead. Machine independence and third generation computers. In Proceedings SJCC (Sprint Joint Computer Conference), pages 587-592, 1967.</p> <p>Hals70</p> <p>M.H. Halstead. Using the computer for program conversion. Datamation, pages 125-129, May 1970.</p> <p>Sass66</p> <p>W.A. Sassaman. A computer program to translate machine language into Fortran. In Proceedings SJCC, pages 235-239, 1966.</p> <p>Hous73</p> <p>B.C. Housel. A Study of Decompiling Machine Languages into High-Level Machine Independent Languages. PhD dissertation, Purdue University, Computer Science, August 1973.</p> <p>Hous73b</p> <p>B.C. Housel and M.H. Halstead. A methodology for machine language decompilation. Technical Report RJ 1316 (#20557), Purdue University, Department of Computer Science, December 1973. Also published as [ <a href=HistoryOfDecompilation1.html#RefHH74>HH74</a> ].</p> <p>Holl73</p> <p>C.R. Hollander. Decompilation of Object Programs. PhD dissertation, Stanford University, Computer Science, January 1973.</p> <p>FS73</p> <p>F.L. Friedman and V.B.Schneider. A Systems Implementation Language. <a href=ACM.html>ACM</a> <a href=SIGPLAN.html>SIGPLAN</a> Notices 8(9), pages 60-63, September 1973.</p> <p>HH74</p> <p>B.C. Housel and M.H. Halstead. A methodology for machine language decompilation. In Proceedings of the 27<sup>th</sup> <a href=ACM.html>ACM</a> Annual Conference, <a href=ACM.html>ACM</a> Press, pages 254-260, 1974.</p> <p>Barb74</p> <p>P. Barbe. The Piler system of computer program translation. Technical report PLR-020, Probe Consultants Inc., September 1974. Prepared for the Office of Naval Research, distributed by National Technical Information Service, USA. ADA000294. Contract N00014-67-C-0472.</p> <p>Frie74</p> <p>F.L. Friedman. Decompilation and the Transfer of Mini-Computer Operating Systems. PhD dissertation, Purdue University, Computer Science, August 1974.</p> <p>Schn74</p> <p>V. Schneider and G. Winiger. Translation grammars for compilation and decompilation. BIT, 14:78-86, 1974.</p> <p>Bake77</p> <p>B.S. Baker. An algorithm for structuring flowgraphs. Journal of the <a href=ACM.html>ACM</a>, 24(1):98-120, January 1977.</p> <p>Hopw78</p> <p>G.L. Hopwood. Decompilation. PhD dissertation, University of California, Irvine, Computer Science, 1978.</p> <p>Work78</p> <p>D.A. Workman. Language design using decompilation. Technical report, University of Central Florida, December 1978.</p> <p>Balb79</p> <p>D. Balbinot and L. Petrone. Decompilation of Polish code in Basic. Rivista di Informatica, 9(4):329-335, October 1979.</p> <p>Bert81</p> <p>M.N. Bert and L. Petrone. Decompiling context-free languages from their Polish-like representations. pages 35-57, 1981.</p> <p>May88</p> <p>W. May. A simple decompiler. Dr.Dobb's Journal, pages 50-52, June 1988.</p> <p>Cifu94</p> <p>C. Cifuentes. Reverse Compilation Techniques. PhD Dissertation. Queensland University of Technology, Department of Computing Science, 1994. Also as <a href="/web/20250209111900/https://program-transformation.org/twiki/bin/viewfile/Transform/CristinaCifuentes7d5a.html?rev=/sw/bin/rlog%20%20-h%20/users/www/staff/research/projects/stratego/twiki/pub/Transform/CristinaCifuentes/decompilation_thesis.ps.gz,v&filename=decompilation_thesis.ps.gz">compressed postscript</a>.</p> <p>Holl73</p> <p>C.R. Hollander. Decompilation of Object Programs. PhD dissertation, Stanford University, Computer Science, January 1973.</p> <p>Hous73</p> <p>B.C. Housel. A Study of Decompiling Machine Languages into High-Level Machine Independent Languages. PhD dissertation, Purdue University, Computer Science, August 1973.</p> <p>Hous73b</p> <p>B.C. Housel and M.H. Halstead. A methodology for machine language decompilation. Technical Report RJ 1316 (#20557), Purdue University, Department of Computer Science, December 1973.</p> <p>Barb74</p> <p>P. Barbe. The Piler system of computer program translation. Technical report, Probe Consultants Inc., September 1974.</p> <p>Frie74</p> <p>F.L. Friedman. Decompilation and the Transfer of Mini-Computer Operating Systems. PhD dissertation, Purdue University, Computer Science, August 1974.</p> <p>Bake77</p> <p>B.S. Baker. An algorithm for structuring flowgraphs. Journal of the <a href=ACM.html>ACM</a>, 24(1):98-120, January 1977.</p> <p>Brin81</p> <p>D.L. Brinkley. Intercomputer transportation of assembly language software through decompilation. Technical report, Naval Underwater Systems Center, October 1981.</p> <p>Bert81</p> <p>M.N. Bert and L. Petrone. Decompiling context-free languages from their Polish-like representations. pages 35-57, 1981.</p> <p>Katz82</p> <p>R.H. Katz and E. Wong. Decompiling CODASYL DML into relational queries. <a href=ACM.html>ACM</a> Transactions on Database Systems, 7(1):1-23, March 1982.</p> <p>Dors82</p> <p>L.M. Dorsey and S.Y. Su. The decompilation of <a href=COBOL.html>COBOL</a>-DML programs for the purpose of program conversion. In Proceedings of <a href=COMPSAC.html>COMPSAC</a> 82. <a href=IEEE.html>IEEE</a> Computer Society's Sixth International Computer Software and Applications Conference, pages 495-504, Chicago, USA, November 1982. <a href=IEEE.html>IEEE</a>.</p> <p>Dudl82</p> <p>R. Dudley. A recursive decompiler. FORTH Dimensions, 4(2):28, Jul-Aug 1982.</p> <p>Hill84</p> <p>N.L. Hills and D. Moines. Revisited: Recursive decompiler. FORTH Dimensions, 5(6):16-18, Mar-Apr 1984.</p> <p>Woo85</p> <p>C.W. Yoo. An approach to the transportation of computer software. Information Processing Letters, 21:153-157, September 1985.</p> <p>May88</p> <p>W. May. A simple decompiler. Dr.Dobb's Journal, pages 50-52, June 1988.</p> <p>Reut88</p> <p>J. Reuter. Formerly available from <a href=https://web.archive.org/web/20250214145422/ftp://ftp.cs.washington.edu/pub/decomp.tar.Z>ftp://ftp.cs.washington.edu/pub/decomp.tar.Z</a>. Public domain software, 1988. Now downloadable from the <a href=DecompDecompiler.html>DecompDecompiler</a> page.</p> <p>Zong88</p> <p>Liu Zongtian and Zhu Yifen, The Application of the Symbolic Execution to the 68000 C Anti-compiler, Chinese Journal of Computers, 11(10):633-637, 1988.</p> <p>War89</p> <p>M. Ward, "Proving Program Refinements and Transformations", Oxford University, PhD Thesis, 1989.</p> <p>Guth90</p> <p>S. Guthery. exe2c. News item in comp.compilers USENET newsgroup, 30 Apr 1990.</p> <p>Guth91a</p> <p>S. Guthery. exe2c. News item in comp.compilers USENET newsgroup, 23 Apr 1991.</p> <p>Reut91</p> <p>J. Reuter. Private communication. Email, 1991.</p> <p>Aust91</p> <p>Austin Code Works. exe2c. Beta release, 1991. Email: <a href=https://web.archive.org/web/20250214145422/mailto:info@acw.com>info@acw.com</a>.</p> <p>Bowe91a</p> <p>J.P. Bowen, P.T. Breuer, and K.C. Lano. The REDO project: Final report. Technical Report PRG-TR-23-91, Oxford University Computing Laboratory, 11 Keble Road, Oxford OX1 3QD, December 1991.</p> <p>Bowe91b</p> <p>J. Bowen and P. Breuer. Decompilation techniques. Internal to ESPRIT REDO project no. 2487 2487-TN-PRG-1065 Version 1.2, Oxford University Computing Laboratory, 11 Keble Road, Oxford OX1 3QD, March 1991.</p> <p>Bowe91c</p> <p>J. Bowen. From programs to object code using logic and logic programming. In R. Giegerich and S.L. Graham, editors, Code Generation - Concepts, Tools, Techniques, Workshops in Computing, pages 173-192, Dagstuhl, German</p> <p>Hood91</p> <p>S.T. Hood. Decompiling with definite clause grammars. Technical Report ERL-0571-RR, Electronics Research Laboratory, DSTO Australia, PO Box 1600, Salisbury, South Australia 5108, September 1991.</p> <p>Hung91</p> <p>L. Hungmong, L. Zongtian, and Z. Yifen. Design and implementation of the intermediate language in a PC decompiler system. Mini-Micro Systems, 12(2):23-28,46, 1991.</p> <p>Fuan91</p> <p>C. Fuan and L. Zongtian. C function recognition technique and its implementation in 8086 C decompiling system. Mini-Micro Systems, 12(11):33-40,47, 1991.</p> <p>Guth91b</p> <p>S. Guthery. Private communication. Austin Code Works, 11100 Leafwood Lane, Austin, TX 78750-3587, 14 Dec 1991.</p> <p>OGor91</p> <p>J. O'Gorman. Systematic Decompilation. PhD Thesis. Technical Report UL-CSIS-91-12, University of Limerick, 1991. <a href=URL.html>URL</a>: <a href=https://web.archive.org/web/20250214145422/ftp://www.csis.ul.ie/techrpts/ul-91-12.ps>ftp://www.csis.ul.ie/techrpts/ul-91-12.ps</a></p> <p>Breu92</p> <p>P.T. Breuer and J.P. Bowen. Decompilation: The enumeration of types and grammars. Technical Report PRG-TR-11-92, Oxford University Computing Laboratory, 11 Keble Road, Oxford OX1 3QD, 1992.</p> <p>Bowe93</p> <p>J. Bowen. From programs to object code and back again using logic programming: Compilation and decompilation. Journal of Software Maintenance: Research and Practice. 5(4):205-234, 1993.</p> <p>Breu93</p> <p>P.T. Breuer and J.P. Bowen. Decompilation: the enumeration of types and grammars. Transaction of Programming Languages and Systems, 1993.</p> <p>Bowe93b</p> <p>J. Bowen, P. Breuer, and K. Lano. A compendium of formal techniques for software maintenance. Software Engineering Journal, pages 253-262, September 1993.</p> <p>Pave93</p> <p>D.J. Pavey and L.A. Winsborrow. Demonstrating equivalence of source code and PROM contents. The Computer Language, 36(7):654-667, 1993.</p> <p>Fuan93</p> <p>C. Fuan, L. Zongtian, and L. Li. Design and implementation techniques of the 8086 C decompiling system. Mini-Micro Systems, 14(4):10-18,31, 1993. Chinese language.</p> <p>Breu94</p> <p>P.T. Breuer and J.P. Bowen. Generating decompilers. Information and Software Technology Journal, 1994.</p> <p>Site93</p> <p>R.L. Sites, A. Chernoff, M.B. Kirk, M.P. Marks, and S.G. Robinson. Binary translation. Communications of the <a href=ACM.html>ACM</a>, 36(2):69-81, February 1993.</p> <p>Cifu94</p> <p>C. Cifuentes. Reverse Compilation Techniques. PhD Dissertation. Queensland University of Technology, Department of Computing Science, 1994.</p> <p>DRM95</p> <p>DECLER User Guide and Reference Manual. Microcomputer Institute, Hefei University of Technology, 1995.3.</p> <p>Zong96</p> <p>Liu Zongtian. DECLER: the C Lanuage Decompilation System. Microelectronics and Computer, 17(5):1-3.</p> <p>Mycr99</p> <p>A. Mycroft. Type-Based Decompilation. Proceedings of ESOP'99, <a href=LNCS.html>LNCS</a> 1576, Springer-Verlag, 1999.</p> <p>War99</p> <p>M. P. Ward. Assembler to C Migration using the <a href=FermaT.html>FermaT</a> Transformation System. Proceedings of ACSM'99, pp67-76.</p> <p>CVEU+99</p> <p>C. Cifuentes, M. Van Emmerik, D. Ung, D. Simon, and T. Waddington. Preliminary experiences with the use of the UQBT binary translation framework. In <em>Proc. Workshop on Binary Translation</em>, Newport Beach, pages 12-22. Technical Committee on Technical Architecture Newsletter, <a href=IEEE.html>IEEE</a> CS-Press, Dec 1999.</p> <p>CL00</p> <p>Kaiming Chen, Zongtian Liu, Recognition and Recovery of Switch Structure in Decompilation System, Mini-Micro Systems, 21(12):1279-1281, 2001. Chinese language.</p> <p>CVE00</p> <p>C. Cifuentes and M. Van Emmerik. UQBT: Adaptable Binary Translation at low cost. <em>Computer</em> 33(3) pages 60-66, March 2000.</p> <p>SML03</p> <p>M. P. Ward. Pigs from Sausages? Reengineering from Assembler to C via <a href=FermaT.html>FermaT</a> Transformation. White paper, <a href=https://web.archive.org/web/20250214145422/http://www.smltd.com/migration-t.pdf>http://www.smltd.com/migration-t.pdf</a>, April 2003. Published in <em>Science of Computer Programming Special Issue: Transformations Everywhere</em> 52(1-3):213-255, 2004.</p> <p>JSW00</p> <p>A. Johnstone, E. Scott, and T. Womack. Reverse Compilation for Digital Signal Processors: a Working Example. In <em>Proceedings of the Hawaii International Conference on System Sciences</em>. <a href=IEEE.html>IEEE</a>-CS Press, January 2000.</p> <p>KO01</p> <p>S. Katumata and A. Ohori. Proof-directed de-compilation of low-level code. In <em>European Symposium on Programming</em>, volume 2028 of Lecture Notes in Computer Science, pages 352-366. Springer-Verlag 2001.</p> <p>Myc01</p> <p>A. Mycroft. Comparing type-based and proof-directed decompilation. In <em>Proceedings of the Working Conference on Reverse Engineering</em>, pages 362-367, Stuttgart Germany. <a href=IEEE.html>IEEE</a>-CS Press 2001.</p> <p>CWVE01</p> <p>C. Cifuences, T. Waddington, and M. Van Emmerik. Computer Security Analysis through Decompilation and High Level Debugging. In <em>Proceedings of the Working Conference on Reverse Engineering</em>, pages 375-380, Stuttgart Germany. <a href=IEEE.html>IEEE</a>-CS Press 2001.</p> <p>Gui01</p> <p>I. Guilfanov. A simple type system for program reengineering. In <em>Proceedings of the Working Conference on Reverse Engineering</em>, pages 357-361, Stuttgart Germany. <a href=IEEE.html>IEEE</a>-CS Press 2001.</p> <p>Jan02</p> <p>AndrÔøΩ Janz. Experimente mit einem Decompiler im Hinblick auf die forensische Informatik, 2002. <a href=https://web.archive.org/web/20250212082115/http://agn-www.informatik.uni-hamburg.de/papers/doc/diparb_andre_janz.pdf>http://agn-www.informatik.uni-hamburg.de/papers/doc/diparb_andre_janz.pdf</a> .</p> <p>TC02</p> <p>J. TrÔøΩger and C. Cifuentes. Analysis of virtual method invocation for binary translation. In <em>Proceedings of the Working Conference on Reverse Engineering</em>, Richmond, Virginia; pages 65-74. <a href=IEEE.html>IEEE</a>-CS Press, 2002.</p> <p>BR04</p> <p>G. Balakrishnan and T. Reps. Analyzing Memory Accesses in x86 Executables. In <em>Proceedings of Compiler Construction</em> (<a href=LNCS.html>LNCS</a> 2985) pages 5-23. Springer-Verlag April 2004.</p> <p>Fal04</p> <p>R. Falke. Entwicklung eines Typeanalysesystem fÔøΩÔøΩÔøΩr einen Decompiler (Development of a type analysis system for a decompiler), 2004. Diploma thesis, German language. <a href=https://web.archive.org/web/20250212082115/http://risimo.net/diplom.ps>http://risimo.net/diplom.ps</a> . No longer available, however archived <a href=https://web.archive.org/web/20250212082115/http://web.archive.org/web/*/http://risimo.net/diplom.ps>here</a> (archive.org, 491kB).</p> <p>Shu04</p> <p>Andrey Shulga. Andromeda Decompiler web page, 2004. <a href=https://web.archive.org/web/20250212082115/http://shulgaaa.at.tut.by/ >http://shulgaaa.at.tut.by</a> .</p> <p>RBLT05</p> <p>T. Reps, G. Balakrishnan, J. Lim and T. Teilelbaum. A Next-Generation Platform for Analysing Executables. To appear in <em>Proc. 3<sup>rd</sup> Asian Symposium on Programming Languages and Systems</em>, Springer-Verlag 2005.</p> <p>Gui07a</p> <p>I. Guilfanov. Blog: Decompilation Gets Real, April 2007. <a href=https://web.archive.org/web/20250212082115/http://hexblog.com/2007/04/decompilation_gets_real.html>http://hexblog.com/2007/04/decompilation_gets_real.html</a> .</p> <p>Gui07b</p> <p>I. Guilfanov. Hex-rays home page, 2007. <a href=https://web.archive.org/web/20250212082115/http://www.hex-rays.com/ >http://www.hex-rays.com</a> .</p> <p>VE07</p> <p>M. Van Emmerik. Static Single Assignment for Decompilation. PhD thesis, University of Queensland, 2007. <a href=https://web.archive.org/web/20250212082115/http://vanemmerikfamily.com/mike/master.pdf>http://vanemmerikfamily.com/mike/master.pdf</a> or <a href=https://web.archive.org/web/20250212082115/http://vanemmerikfamily.com/mike/master.ps.gz>http://vanemmerikfamily.com/mike/master.ps.gz</a> .</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2024 Decompilation Wiki Team </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"annotate": null, "base": "../..", "features": ["navigation.tabs", "search.suggest", "search.highlight", "search.share", "toc.integrate"], "search": "../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../assets/javascripts/bundle.e71a0d61.min.js></script> <script src=https://cdnjs.loli.net/ajax/libs/pangu/3.3.0/pangu.min.js></script> <script src=../../static/js/extra.js></script> <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>